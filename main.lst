ca65 V2.16 - Git f19651c
Main file   : main.asm
Current file: main.asm

000000r 1               .include "header.inc"
000000r 2               ; Sets up ROM headers/vectors
000000r 2               
000000r 2               .p816   ; 65816 processor
000000r 2               .i16    ; X/Y are 16 bits
000000r 2               .a8     ; A is 8 bits
000000r 2               .feature force_range
000000r 2               
000000r 2               .define ROM_NAME "physics demo         "
000000r 2                               ;"123456789012345678901"
000000r 2               .segment "HEADER"     ; +$7FE0 in file
000000r 2  70 68 79 73      .byte ROM_NAME
000004r 2  69 63 73 20  
000008r 2  64 65 6D 6F  
000015r 2               
000015r 2               .segment "ROMINFO"    ; +$7FD5 in file
000000r 2  30               .byte $30         ; LoROM, fast-capable
000001r 2  00               .byte 0           ; no battery RAM
000002r 2  07               .byte $07         ; 128K ROM
000003r 2  00 00 00 00      .byte 0,0,0,0
000007r 2  AA AA 55 55      .word $AAAA,$5555 ; dummy checksum and complement
00000Br 2               
00000Br 2               ;cop,brk,abort,nmi,reset,irq
00000Br 2               ;cop,abort,nmi,res,brk,irqbrk
00000Br 2               .segment "VECTORS"
000000r 2  00 00 00 00      .word 0, 0, EmptyHandler0, EmptyHandler1, EmptyHandler2, VBlank, Reset, EmptyHandler3
000004r 2  rr rr rr rr  
000008r 2  rr rr rr rr  
000010r 2  00 00 00 00      .word 0, 0, EmptyHandler4, EmptyHandler5, VBlank, EmptyHandler6, Reset, EmptyHandler7
000014r 2  rr rr rr rr  
000018r 2  rr rr rr rr  
000020r 2               
000020r 2               .segment "CODE"
000000r 2               EmptyHandler0:
000000r 2  40           	rti
000001r 2               EmptyHandler1:
000001r 2  4C rr rr     	jmp CrashHandler
000004r 2  40           	rti
000005r 2               EmptyHandler2:
000005r 2  40           	rti
000006r 2               EmptyHandler3:
000006r 2  40           	rti
000007r 2               EmptyHandler4:
000007r 2  40           	rti
000008r 2               EmptyHandler5:
000008r 2  40           	rti
000009r 2               EmptyHandler6:
000009r 2  40           	rti
00000Ar 2               EmptyHandler7:
00000Ar 2  40           	rti
00000Br 2               
00000Br 1               .include "snes.inc"
00000Br 2               ;
00000Br 2               ; S-CPU and S-PPU MMIO port definitions for Super NES
00000Br 2               ; and useful 65816 macros
00000Br 2               ;
00000Br 2               ; Copyright 2014-2015 Damian Yerrick
00000Br 2               ;
00000Br 2               ; Copying and distribution of this file, with or without
00000Br 2               ; modification, are permitted in any medium without royalty provided
00000Br 2               ; the copyright notice and this notice are preserved in all source
00000Br 2               ; code copies.  This file is offered as-is, without any warranty.
00000Br 2               ;
00000Br 2               
00000Br 2               ;
00000Br 2               ; This header summarizes some of the Super NES MMIO ports.
00000Br 2               ; For more details, see these web pages:
00000Br 2               ; http://wiki.superfamicom.org/
00000Br 2               ; http://problemkaputt.de/fullsnes.htm
00000Br 2               ;
00000Br 2               ; Names of MMIO ports in this header file may differ from purported
00000Br 2               ; official names for two reasons: to avoid the appearance of
00000Br 2               ; misappropriation, and because sometimes these make more sense.
00000Br 2               ;
00000Br 2               
00000Br 2               .ifndef SNES_H
00000Br 2               .define SNES_H
00000Br 2               
00000Br 2               ; S-PPU configuration ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               PPUBRIGHT = $2100
00000Br 2               ; 76543210
00000Br 2               ; |   ++++- brightness (F: max)
00000Br 2               ; +-------- 1: disable rendering
00000Br 2               FORCEBLANK = $80
00000Br 2               
00000Br 2               PPURES = $2133
00000Br 2               ; 76543210
00000Br 2               ; ||  |||+- Screen interlace
00000Br 2               ; ||  ||+-- Shrink sprites vertically during interlace
00000Br 2               ; ||  |+--- 0: show lines 1-224; 1: show lines 1-239
00000Br 2               ; ||  +---- Show subscreen in left half of each pixel
00000Br 2               ; ||        (modes 012347; forced on in modes 56)
00000Br 2               ; |+------- In mode 7, use bit 7 as priority
00000Br 2               ; +-------- External genlock, intended for SFC Titler. Use 0 on SNES.
00000Br 2               INTERLACE    = $01
00000Br 2               INTERLACEOBJ = $02
00000Br 2               BG_TALL      = $04
00000Br 2               SUB_HIRES    = $08
00000Br 2               M7_EXTBG     = $40
00000Br 2               
00000Br 2               PPUSTATUS1 = $213E
00000Br 2               ; 76543210  PPU address generator status
00000Br 2               ; ||  ++++- PPU1 version (always 1)
00000Br 2               ; |+------- 1: sprite overflow (>32 on a line) since the last vblank end
00000Br 2               ; +-------- 1: sliver overflow (>34 on a line) since the last vblank end
00000Br 2               ; this parallels bit 5 of $2002 on NES
00000Br 2               
00000Br 2               PPUSTATUS2 = $213F
00000Br 2               ; 76543210  PPU compositor status
00000Br 2               ; || |++++- PPU2 version (1-3, not counting minor versions of 3)
00000Br 2               ; || +----- 1: PAL
00000Br 2               ; |+------- 1: GETXY has happened since last PPUSTATUS2 read
00000Br 2               ; +-------- Toggles every vblank
00000Br 2               
00000Br 2               ; S-PPU sprites ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               OBSEL = $2101
00000Br 2               ; 76543210
00000Br 2               ; ||||| ++- Sprite main pattern table (0=$0000, 1=$2000, 2=$4000, 3=$6000)
00000Br 2               ; |||++---- Alt pattern table offset (0=$1000, 1=$2000, 2=$3000, 3=$4000)
00000Br 2               ; +++------ 0: 8/16; 1: 8/32; 2: 8/64; 3: 16/64; 4: 32/64; 5: 64/64
00000Br 2               ;           (all sprites are square and 2D-mapped)
00000Br 2               OBSIZE_8_16  = $00
00000Br 2               OBSIZE_8_32  = $20
00000Br 2               OBSIZE_8_64  = $40
00000Br 2               OBSIZE_16_32 = $60
00000Br 2               OBSIZE_16_64 = $80
00000Br 2               OBSIZE_32_64 = $A0
00000Br 2               
00000Br 2               OAMADDR = $2102  ; 16-bit, 128 sprites followed by high-X/size table
00000Br 2               OAMDATA = $2104
00000Br 2               OAMDATARD = $2138
00000Br 2               ; Parallels NES $2003, except apparently word-addressed.
00000Br 2               ; OAM random access is working here, unlike on NES.
00000Br 2               ; If bit 15 is set, value at start of frame apparently also
00000Br 2               ; controls which sprites are in front
00000Br 2               
00000Br 2               ; S-PPU background configuration ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               BGMODE = $2105
00000Br 2               ; 76543210
00000Br 2               ; |||||+++- 0: 4 planes 2 bpp
00000Br 2               ; |||||     1: 2 planes 4 bpp, 1 plane 2 bpp
00000Br 2               ; |||||     2: 2 planes 4 bpp, OPT
00000Br 2               ; |||||     3: 1 plane 8 bpp, 1 plane 4 bpp
00000Br 2               ; |||||     4: 1 plane 8 bpp, 1 plane 2 bpp, OPT
00000Br 2               ; |||||     5: 1 plane 4 bpp, 1 plane 2 bpp, hires
00000Br 2               ; |||||     6: 1 plane 4 bpp, OPT, hires
00000Br 2               ; |||||     7: 1 plane rot/scale
00000Br 2               ; ||||+---- In mode 1, set plane 2 high-prio in front of all others
00000Br 2               ; |||+----- Plane 0 tile size (0: 8x8, 1: 16x16)
00000Br 2               ; ||+------ Plane 1 tile size (0: 8x8, 1: 16x16)
00000Br 2               ; |+------- Plane 2 tile size (0: 8x8, 1: 16x16)
00000Br 2               ; +-------- Plane 3 tile size (0: 8x8, 1: 16x16)
00000Br 2               ;           Modes 5 and 6 use 16x8 instead of 8x8
00000Br 2               ;           Mode 7 always uses 8x8
00000Br 2               
00000Br 2               MOSAIC = $2106
00000Br 2               ; 76543210
00000Br 2               ; |||||||+- Apply mosaic to plane 0 (or mode 7 high-prio horizontal)
00000Br 2               ; ||||||+-- Apply mosaic to plane 1 (or mode 7 high-prio vertical)
00000Br 2               ; |||||+--- Apply mosaic to plane 2
00000Br 2               ; ||||+---- Apply mosaic to plane 3
00000Br 2               ; ++++----- Pixel size minus 1 (0=1x1, 15=16x16)
00000Br 2               
00000Br 2               NTADDR = $2107  ; through $210A
00000Br 2               ; 76543210
00000Br 2               ;  ||||||+- Nametable width (0: 1 screen, 1: 2 screens)
00000Br 2               ;  |||||+-- Nametable height (0: 1 screen, 1: 2 screens)
00000Br 2               ;  +++++--- Nametable base address in $400 units
00000Br 2               ; Each nametable in modes 0-6 is 32 rows, each 32 spaces long.
00000Br 2               .define NTXY(xc,yc) ((xc)|((yc)<<5))
00000Br 2               
00000Br 2               BGCHRADDR = $210B
00000Br 2               ; FEDCBA98 76543210
00000Br 2               ;  ||| |||  ||| +++- Pattern table base address for plane 0
00000Br 2               ;  ||| |||  +++----- Same for plane 1
00000Br 2               ;  ||| +++---------- Same for plane 2
00000Br 2               ;  +++-------------- Same for plane 3
00000Br 2               
00000Br 2               M7SEL = $211A
00000Br 2               ; 76543210
00000Br 2               ; ||    ||
00000Br 2               ; ||    |+- Flip screen horizontally
00000Br 2               ; ||    +-- Flip screen vertically
00000Br 2               ; ++------- 0: repeat entire mode 7 plane
00000Br 2               ;           2: transparent outside; 3: tile $00 repeating outside
00000Br 2               M7_HFLIP    = $01
00000Br 2               M7_VFLIP    = $02
00000Br 2               M7_WRAP     = $00
00000Br 2               M7_NOWRAP   = $80
00000Br 2               M7_BORDER00 = $C0
00000Br 2               
00000Br 2               ; S-PPU scrolling ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               BGSCROLLX = $210D  ; double write low then high (000-3FF m0-6, 000-7FF m7)
00000Br 2               BGSCROLLY = $210E  ; similar. reg 210F-2114 are same for other planes
00000Br 2               ; Hi-res scrolling in modes 5-6 moves by whole (sub+main) pixels in X
00000Br 2               ; but half scanlines in Y.
00000Br 2               ; The top visible line is the line below the value written here.
00000Br 2               ; For example, in 224-line mode, if 12 is written, lines 13 through
00000Br 2               ; 237 of the background are visible.  This differs from the NES.
00000Br 2               ;
00000Br 2               ; Mode 7 uses this value as the center of rotation.  This differs
00000Br 2               ; from the GBA, which fixes the center of rotation at the top left.
00000Br 2               
00000Br 2               ; 211B-2120 control mode 7 matrix; to be documented later
00000Br 2               
00000Br 2               ; S-PPU VRAM data port ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               PPUCTRL = $2115
00000Br 2               ; 76543210
00000Br 2               ; |   ||++- VRAM address increment (1, 32, 128, 128)
00000Br 2               ; |   ++--- Rotate low bits of address left by 3 (off, 8, 9, or 10)
00000Br 2               ; +-------- 0: Increment after low data port access; 1: after high
00000Br 2               ; Corresponds to bit 2 of $2000 on NES
00000Br 2               VRAM_DOWN   = $01
00000Br 2               VRAM_M7DOWN = $02
00000Br 2               INC_DATAHI  = $80
00000Br 2               
00000Br 2               PPUADDR = $2116  ; Word address, not double-write anymore
00000Br 2               PPUDATA = $2118
00000Br 2               PPUDATAHI = $2119
00000Br 2               PPUDATARD = $2139  ; Same dummy read as on NES is needed
00000Br 2               PPUDATARDHI = $213A
00000Br 2               
00000Br 2               ; S-PPU palette ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               CGADDR = $2121
00000Br 2               CGDATA = $2122  ; 5-bit BGR, write twice, low byte first
00000Br 2               CGDATARD = $213B  ; 5-bit BGR, read twice, low byte first
00000Br 2               .define RGB(r,g,b) ((r)|((g)<<5)|((b)<<10))
00000Br 2               
00000Br 2               ; S-PPU window ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               BG12WINDOW = $2123
00000Br 2               BG34WINDOW = $2124
00000Br 2               OBJWINDOW = $2125
00000Br 2               ; 76543210
00000Br 2               ; ||||||++- 0: disable window 1 on BG1/BG3/OBJ; 2: enable; 3: enable outside
00000Br 2               ; ||||++--- 0: disable window 2 on BG1/BG3/OBJ; 2: enable; 3: enable outside
00000Br 2               ; ||++----- 0: disable window 1 on BG2/BG4; 2: enable; 3: enable outside
00000Br 2               ; ++------- 0: disable window 2 on BG2/BG4; 2: enable; 3: enable outside
00000Br 2               
00000Br 2               WINDOW1L = $2126
00000Br 2               WINDOW1R = $2127
00000Br 2               WINDOW2L = $2128
00000Br 2               WINDOW2R = $2129
00000Br 2               
00000Br 2               BGWINDOP = $212A   ; Window op is how windows are combined when both
00000Br 2               OBJWINDOP = $212B  ; windows 1 and 2 are enabled.
00000Br 2               ; 76543210
00000Br 2               ; ||||||++- Window op for plane 0 or sprites (0: or, 1: and, 2: xor, 3: xnor)
00000Br 2               ; ||||++--- Window op for plane 1 or color window
00000Br 2               ; ||++----- Window op for plane 2
00000Br 2               ; ++------- Window op for plane 3
00000Br 2               
00000Br 2               ; S-PPU blending (or "color math") ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               ; The main layer enable reg, corresponding to PPUMASK on the NES,
00000Br 2               ; is BLENDMAIN.
00000Br 2               BLENDMAIN  = $212C  ; Layers enabled for main input of blending
00000Br 2               BLENDSUB   = $212D  ; Layers enabled for sub input of blending
00000Br 2               WINDOWMAIN = $212E  ; Windows enabled for main input of blending
00000Br 2               WINDOWSUB  = $212F  ; Windows enabled for sub input of blending
00000Br 2               ; 76543210
00000Br 2               ;    ||||+- plane 0
00000Br 2               ;    |||+-- plane 1
00000Br 2               ;    ||+--- plane 2
00000Br 2               ;    |+---- plane 3
00000Br 2               ;    +----- sprites
00000Br 2               ; BLENDMAIN roughly parallels NES $2001 bits 4-3,
00000Br 2               ; except that turning off both bits doesn't disable rendering.
00000Br 2               ; (Use PPUBRIGHT for that.)
00000Br 2               
00000Br 2               ; PPU1 appears to generate a stream of (main, sub) pairs, which
00000Br 2               ; PPU2 combines to form output colors.
00000Br 2               
00000Br 2               ; Blending parameters not documented yet.  Wait for a future demo.
00000Br 2               
00000Br 2               ; When BGMODE is 0-6 (or during vblank in mode 7), a fast 16x8
00000Br 2               ; signed multiply is available, finishing by the next CPU cycle.
00000Br 2               M7MCAND = $211B    ; write low then high
00000Br 2               M7MUL = $211C      ; 8-bit factor
00000Br 2               M7PRODLO = $2134
00000Br 2               M7PRODHI = $2135
00000Br 2               M7PRODBANK = $2136
00000Br 2               
00000Br 2               GETXY = $2137  ; read while $4201 D7 is set: populate x and y coords
00000Br 2               XCOORD = $213C  ; used with light guns, read twice
00000Br 2               YCOORD = $213D  ; also read twice
00000Br 2               
00000Br 2               ; SPC700 communication ports ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               APU0 = $2140
00000Br 2               APU1 = $2141
00000Br 2               APU2 = $2142
00000Br 2               APU3 = $2143
00000Br 2               
00000Br 2               ; S-CPU interrupt control ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               PPUNMI = $4200
00000Br 2               ; 76543210
00000Br 2               ; | ||   +- Automatically read controllers in first 4 lines of vblank
00000Br 2               ; | ++----- 0: No IRQ; 1: IRQs at HTIME;
00000Br 2               ; |         2: one IRQ at (0, VTIME); 3: one IRQ at (HTIME, VTIME)
00000Br 2               ; +-------- 1: Enable NMI at start of vblank
00000Br 2               VBLANK_NMI = $80
00000Br 2               HTIME_IRQ  = $10
00000Br 2               VTIME_IRQ  = $20
00000Br 2               HVTIME_IRQ = $30
00000Br 2               AUTOREAD   = $01
00000Br 2               
00000Br 2               HTIME   = $4207
00000Br 2               HTIMEHI = $4208
00000Br 2               VTIME   = $4209
00000Br 2               VTIMEHI = $420A
00000Br 2               
00000Br 2               NMISTATUS = $4210
00000Br 2               ; 76543210
00000Br 2               ; |   ||||
00000Br 2               ; |   ++++- DMA controller version (1, 2) where v1 has an HDMA glitch
00000Br 2               ; +-------- 1: Vblank has started since last read (like $2002.d7 on NES)
00000Br 2               
00000Br 2               TIMESTATUS = $4211  ; Acknowledge htime/vtime IRQ
00000Br 2               VBLSTATUS = $4212
00000Br 2               ; 76543210
00000Br 2               ; ||     +- 0: Controller reading finished; 1: busy
00000Br 2               ; |+------- In hblank
00000Br 2               ; +-------- In vblank
00000Br 2               
00000Br 2               ROMSPEED = $420D  ; 0: slow ROM everywhere; 1: fast ROM in banks 80-FF
00000Br 2                                 ; (requires 120ns or faster PRG ROM)
00000Br 2               
00000Br 2               ; S-CPU controller I/O ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               ; Manual controller reading behaves almost exactly as on Famicom.
00000Br 2               ; For games using up to 2 standard controllers, these aren't needed,
00000Br 2               ; as you can enable controller autoreading along with vblank NMIs.
00000Br 2               ; But for games using (multitap, mouse, etc.), you will need to
00000Br 2               ; read the extra bits separately after the autoreader finishes.
00000Br 2               JOY0 = $4016
00000Br 2               JOY1 = $4017
00000Br 2               
00000Br 2               ; In addition to the common strobe, each controller port has an
00000Br 2               ; additional output bit that can be used as, say, a chip select
00000Br 2               ; for SPI peripherals.
00000Br 2               JOYOUT = $4201
00000Br 2               ; 76543210
00000Br 2               ; |+------- Controller 1 pin 6 output
00000Br 2               ; +-------- Controller 2 pin 6 output
00000Br 2               
00000Br 2               ; Results of the autoreader
00000Br 2               JOY1CUR = $4218    ; Bit 0: used by standard controllers
00000Br 2               JOY2CUR = $421A
00000Br 2               JOY1B1CUR = $421C  ; Bit 1: used by multitap and a few oddball
00000Br 2               JOY2B1CUR = $421E  ; input devices
00000Br 2               ; FEDCBA98 76543210
00000Br 2               ; BYSRUDLR AXLRTTTT
00000Br 2               ; |||||||| ||||++++- controller type (0: controller, 1: mouse)
00000Br 2               ; |||||||| ||++----- shoulder buttons
00000Br 2               ; ++-------++------- right face buttons
00000Br 2               ;   ||++++---------- Control Pad
00000Br 2               ;   ++-------------- center face buttons
00000Br 2               KEY_B      = $8000
00000Br 2               KEY_Y      = $4000
00000Br 2               KEY_SELECT = $2000
00000Br 2               KEY_START  = $1000
00000Br 2               KEY_UP     = $0800
00000Br 2               KEY_DOWN   = $0400
00000Br 2               KEY_LEFT   = $0200
00000Br 2               KEY_RIGHT  = $0100
00000Br 2               KEY_A      = $0080
00000Br 2               KEY_X      = $0040
00000Br 2               KEY_L      = $0020
00000Br 2               KEY_R      = $0010
00000Br 2               
00000Br 2               ; S-CPU multiply and divide ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               ; Multiply unit.  Also good for shifting pixels when drawing
00000Br 2               ; text in a proportional font.
00000Br 2               CPUMCAND = $4202  ; unchanged by multiplications
00000Br 2               CPUMUL = $4203    ; write here to fill CPUPROD 8 cycles later
00000Br 2               CPUPROD = $4216
00000Br 2               CPUPRODHI = $4217
00000Br 2               
00000Br 2               ; Divide unit
00000Br 2               CPUNUM = $4204
00000Br 2               CPUNUMHI = $4205
00000Br 2               CPUDEN = $4206    ; write divisor to fill CPUQUOT/CPUREM 16 cycles later
00000Br 2               CPUQUOT = $4214
00000Br 2               CPUQUOTHI = $4215
00000Br 2               CPUREM = CPUPROD
00000Br 2               CPUREMHI = CPUPRODHI
00000Br 2               
00000Br 2               ; S-CPU DMA ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               
00000Br 2               COPYSTART = $420B  ; writes of 1 << n start a DMA copy on channel n
00000Br 2               HDMASTART = $420C  ; writes of 1 << n start HDMA on channel n
00000Br 2               ; Don't run a DMA copy while HDMA is enabled, or you might run into
00000Br 2               ; a defect in revision 1 of the S-CPU that causes crashing.
00000Br 2               
00000Br 2               ; There are 8 DMA channels.
00000Br 2               ; Registers for channels 1-7 start at $4310, $4320, ...
00000Br 2               DMAMODE = $4300
00000Br 2               ; 76543210
00000Br 2               ; || ||+++- PPU address offset pattern
00000Br 2               ; || ||     0: 0     1: 01    2: 00    3: 0011  4: 0123  5: 0101
00000Br 2               ; || ++---- Memcpy only: 0: increment; 1: fixed; 2: decrement
00000Br 2               ; |+------- HDMA only: 1: Table contains pointers
00000Br 2               ; +-------- Direction (0: read CPU write PPU; 1: read PPU write CPU)
00000Br 2               DMA_LINEAR   = $00
00000Br 2               DMA_01       = $01
00000Br 2               DMA_00       = $02  ; For HDMA to double write ports; copies can use linear
00000Br 2               DMA_0011     = $03  ; For HDMA to scroll positions and mode 7 matrices
00000Br 2               DMA_0123     = $04  ; For HDMA to window registers
00000Br 2               DMA_0101     = $05  ; Not sure how this would be useful for HDMA
00000Br 2               DMA_FORWARD  = $00
00000Br 2               DMA_CONST    = $08
00000Br 2               DMA_BACKWARD = $10
00000Br 2               DMA_INDIRECT = $40
00000Br 2               DMA_READPPU  = $80
00000Br 2               
00000Br 2               DMAPPUREG = $4301
00000Br 2               DMAADDR = $4302
00000Br 2               DMAADDRHI = $4303
00000Br 2               DMAADDRBANK = $4304
00000Br 2               DMALEN = $4305  ; number of bytes, not number of transfers; 0 means 65536
00000Br 2               DMALENHI = $4306
00000Br 2               
00000Br 2               HDMAINDBANK = $4307
00000Br 2               HDMATABLELO = $4308
00000Br 2               HDMATABLEHI = $4309
00000Br 2               HDMALINE = $430A
00000Br 2               
00000Br 2               ; composite values for use with 16-bit writes to DMAMODE
00000Br 2               DMAMODE_PPULOFILL = (<PPUDATA << 8)       | DMA_LINEAR | DMA_CONST
00000Br 2               DMAMODE_PPUHIFILL = (<(PPUDATA + 1) << 8) | DMA_LINEAR | DMA_CONST
00000Br 2               DMAMODE_PPUFILL   = (<PPUDATA << 8)       | DMA_01     | DMA_CONST
00000Br 2               DMAMODE_PPULODATA = (<PPUDATA << 8)       | DMA_LINEAR | DMA_FORWARD
00000Br 2               DMAMODE_PPUHIDATA = (<(PPUDATA + 1) << 8) | DMA_LINEAR | DMA_FORWARD
00000Br 2               DMAMODE_PPUDATA   = (<PPUDATA << 8)       | DMA_01     | DMA_FORWARD
00000Br 2               DMAMODE_CGDATA    = (<CGDATA << 8)        | DMA_00     | DMA_FORWARD
00000Br 2               DMAMODE_OAMDATA   = (<OAMDATA << 8)       | DMA_00     | DMA_FORWARD
00000Br 2               
00000Br 2               ; FULLSNES NAMES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00000Br 2               ;
00000Br 2               ; These aliases match the names presented in Fullsnes.
00000Br 2               
00000Br 2               ; S-PPU write
00000Br 2               INIDISP = PPUBRIGHT
00000Br 2               OAMADDL = OAMADDR+0
00000Br 2               OAMADDH = OAMADDR+1
00000Br 2               BG1SC   = NTADDR+0
00000Br 2               BG2SC   = NTADDR+1
00000Br 2               BG3SC   = NTADDR+2
00000Br 2               BG4SC   = NTADDR+3
00000Br 2               BG12NBA = BGCHRADDR+0  ; Welcome to...
00000Br 2               BG34NBA = BGCHRADDR+1  ; BG34NBA JAM!!!
00000Br 2               BG1HOFS = BGSCROLLX+0
00000Br 2               BG1VOFS = BGSCROLLY+0
00000Br 2               BG2HOFS = BGSCROLLX+2
00000Br 2               BG2VOFS = BGSCROLLY+2
00000Br 2               BG3HOFS = BGSCROLLX+4
00000Br 2               BG3VOFS = BGSCROLLY+4
00000Br 2               BG4HOFS = BGSCROLLX+6
00000Br 2               BG4VOFS = BGSCROLLY+6
00000Br 2               VMAIN   = PPUCTRL
00000Br 2               VMADDL  = PPUADDR+0
00000Br 2               VMADDH  = PPUADDR+1
00000Br 2               VMDATAL = PPUDATA+0
00000Br 2               VMDATAH = PPUDATA+1
00000Br 2               M7A     = $211B
00000Br 2               M7B     = $211C
00000Br 2               M7C     = $211D
00000Br 2               M7D     = $211E
00000Br 2               M7X     = $211F
00000Br 2               M7Y     = $2120
00000Br 2               CGADD   = CGADDR
00000Br 2               W12SEL  = BG12WINDOW
00000Br 2               W34SEL  = BG34WINDOW
00000Br 2               WOBJSEL = OBJWINDOW
00000Br 2               WH0     = WINDOW1L
00000Br 2               WH1     = WINDOW1R
00000Br 2               WH2     = WINDOW2L
00000Br 2               WH3     = WINDOW2R
00000Br 2               WBGLOG  = BGWINDOP
00000Br 2               WOBJLOG = OBJWINDOP
00000Br 2               TM      = BLENDMAIN
00000Br 2               TS      = BLENDSUB
00000Br 2               TMW     = WINDOWMAIN
00000Br 2               TSW     = WINDOWSUB
00000Br 2               CGWSEL  = $2130
00000Br 2               CGADSUB = $2131
00000Br 2               COLDATA = $2132
00000Br 2               SETINI  = PPURES
00000Br 2               
00000Br 2               ; S-PPU read
00000Br 2               MPYL    = M7PRODLO
00000Br 2               MPYM    = M7PRODHI
00000Br 2               MPYH    = M7PRODBANK
00000Br 2               SLHV    = GETXY
00000Br 2               RDOAM   = OAMDATARD
00000Br 2               RDVRAML = PPUDATARD
00000Br 2               RDVRAMH = PPUDATARDHI
00000Br 2               RDCGRAM = CGDATARD
00000Br 2               OPHCT   = XCOORD
00000Br 2               OPVCT   = YCOORD
00000Br 2               STAT77  = PPUSTATUS1
00000Br 2               STAT78  = PPUSTATUS2
00000Br 2               
00000Br 2               ; other B bus devices
00000Br 2               APUIO0 = APU0  ; didn't want to use capital O with digit 0
00000Br 2               APUIO1 = APU1
00000Br 2               APUIO2 = APU2
00000Br 2               APUIO3 = APU3
00000Br 2               WMDATA = $2180
00000Br 2               WMADDL = $2181
00000Br 2               WMADDM = $2182
00000Br 2               WMADDH = $2183
00000Br 2               
00000Br 2               ; S-CPU I/O write
00000Br 2               NMITIMEN = $4200
00000Br 2               WRIO     = $4201
00000Br 2               WRMPYA   = CPUMCAND
00000Br 2               WRMPYB   = CPUMUL
00000Br 2               WRDIVL   = CPUNUM
00000Br 2               WRDIVH   = CPUNUMHI
00000Br 2               WRDIVB   = CPUDEN
00000Br 2               HTIMEL   = HTIME
00000Br 2               HTIMEH   = HTIMEHI
00000Br 2               VTIMEL   = VTIME
00000Br 2               VTIMEH   = VTIMEHI
00000Br 2               MDMAEN   = COPYSTART  ; where I come from MDMA is a drug
00000Br 2               HDMAEN   = HDMASTART
00000Br 2               MEMSEL   = ROMSPEED
00000Br 2               
00000Br 2               ; S-CPU I/O read
00000Br 2               RDNMI  = NMISTATUS
00000Br 2               TIMEUP = TIMESTATUS
00000Br 2               HVBJOY = VBLSTATUS
00000Br 2               RDIO   = $4213
00000Br 2               RDDIVL = CPUQUOT
00000Br 2               RDDIVH = CPUQUOT+1
00000Br 2               RDMPYL = CPUPROD
00000Br 2               RDMPYH = CPUPROD+1
00000Br 2               JOY1L  = JOY1CUR+0
00000Br 2               JOY1H  = JOY1CUR+1
00000Br 2               JOY2L  = JOY2CUR+0
00000Br 2               JOY2H  = JOY2CUR+1
00000Br 2               JOY3L  = JOY1B1CUR+0
00000Br 2               JOY3H  = JOY1B1CUR+1
00000Br 2               JOY4L  = JOY2B1CUR+0
00000Br 2               JOY4H  = JOY2B1CUR+1
00000Br 2               .endif
00000Br 2               
00000Br 1               .include "initSNES.inc"
00000Br 2               ;------------------------------------------------------------------------
00000Br 2               ;-  Written by: Neviksti
00000Br 2               ;-     If you use my code, please share your creations with me
00000Br 2               ;-     as I am always curious :)
00000Br 2               ;------------------------------------------------------------------------
00000Br 2               
00000Br 2               
00000Br 2               ;----------------------------------------------------------------------------
00000Br 2               ; InitSNES -- my "standard" initialization of SNES memory and registers
00000Br 2               ;----------------------------------------------------------------------------
00000Br 2               .macro InitSNES
00000Br 2                 sei                     ;disable interrupts
00000Br 2                 clc                     ;switch to native mode
00000Br 2                 xce
00000Br 2               
00000Br 2                 REP #$38		; mem/A = 16 bit, X/Y = 16 bit
00000Br 2               			;decimal mode off
00000Br 2                 .i16
00000Br 2                 LDX #$1FFF	;Setup the stack
00000Br 2                 TXS			;Transfer Index X to Stack Pointer Register
00000Br 2               
00000Br 2                 ;do the rest of the initialization in a routine
00000Br 2                 JSL InitializeSNES
00000Br 2               
00000Br 2                 SEP #$20		; mem/A = 8 bit
00000Br 2               .endmacro
00000Br 2               
00000Br 2               ;----------------------------------------------------------------------------
00000Br 2               
00000Br 2               .segment "CODE"
00000Br 2               
00000Br 2               InitializeSNES:
00000Br 2  4B             PHK			;set Data Bank = Program Bank
00000Cr 2  AB             PLB
00000Dr 2               
00000Dr 2  A9 00          LDA #$0000	;set Direct Page = $0000
00000Fr 2  5B             TCD			;Transfer Accumulator to Direct Register
000010r 2               
000010r 2  AE FD 1F       LDX $1FFD		;we clear all the mem at one point ...
000013r 2  8E 72 43       STX $4372  	;so save the return address in a place that won't get overwritten
000016r 2  AE FF 1F       LDX $1FFF
000019r 2  8E 74 43       STX $4374
00001Cr 2               
00001Cr 2  E2 20          SEP #$20		; mem/A = 8 bit
00001Er 2  C2 10          REP #$10
000020r 2               
000020r 2  A9 8F          LDA #$8F
000022r 2  8D 00 21       STA $2100		;turn screen off for now, set brightness to normal
000025r 2               
000025r 2  A2 01 21       LDX #$2101
000028r 2               _Loop00:		;regs $2101-$210C
000028r 2  74 00          STZ $00,X		;set Sprite,Character,Tile sizes to lowest, and set addresses to $0000
00002Ar 2  E8             INX
00002Br 2  E0 0D 21       CPX #$210D
00002Er 2  D0 F8          BNE _Loop00
000030r 2               
000030r 2               _Loop01:		;regs $210D-$2114
000030r 2  74 00          STZ $00,X		;Set all BG scroll values to $0000
000032r 2  74 00          STZ $00,X
000034r 2  E8             INX
000035r 2  E0 15 21       CPX #$2115
000038r 2  D0 F6          BNE _Loop01
00003Ar 2               
00003Ar 2  A9 80          LDA #$80		;reg $2115
00003Cr 2  8D 15 21       STA $2115		; Initialize VRAM transfer mode to word-access, increment by 1
00003Fr 2               
00003Fr 2  9C 16 21       STZ $2116		;regs $2117-$2117
000042r 2  9C 17 21       STZ $2117		;VRAM address = $0000
000045r 2               
000045r 2               			;reg $2118-$2119
000045r 2               			;VRAM write register... don't need to initialize
000045r 2               
000045r 2  9C 1A 21       STZ $211A		;clear Mode7 setting
000048r 2               
000048r 2  A2 1B 21       LDX #$211B
00004Br 2               _Loop02:		;regs $211B-$2120
00004Br 2  74 00          STZ $00,X		;clear out the Mode7 matrix values
00004Dr 2  74 00          STZ $00,X
00004Fr 2  E8             INX
000050r 2  E0 21 21       CPX #$2121
000053r 2  D0 F6          BNE _Loop02
000055r 2               
000055r 2               			;reg $2121 - Color address, doesn't need initilaizing
000055r 2               			;reg $2122 - Color data, is initialized later
000055r 2               
000055r 2  A2 23 21       LDX #$2123
000058r 2               _Loop03:		;regs $2123-$2133
000058r 2  74 00          STZ $00,X		;turn off windows, main screens, sub screens, color addition,
00005Ar 2  E8             INX			;fixed color = $00, no super-impose (external synchronization),
00005Br 2  E0 34 21       CPX #$2134	;no interlaced mode, normal resolution
00005Er 2  D0 F8          BNE _Loop03
000060r 2               
000060r 2               			;regs $2134-$2136  - multiplication result, no initialization needed
000060r 2               			;reg $2137 - software H/V latch, no initialization needed
000060r 2               			;reg $2138 - Sprite data read, no initialization needed
000060r 2               			;regs $2139-$213A  - VRAM data read, no initialization needed
000060r 2               			;reg $213B - Color RAM data read, no initialization needed
000060r 2               			;regs $213C-$213D  - H/V latched data read, no initialization needed
000060r 2               
000060r 2  9C 3E 21       STZ $213E		;reg $213E - might not be necesary, but selects PPU master/slave mode
000063r 2               			;reg $213F - PPU status flag, no initialization needed
000063r 2               
000063r 2               			;reg $2140-$2143 - APU communication regs, no initialization required
000063r 2               
000063r 2               			;reg $2180  -  read/write WRAM register, no initialization required
000063r 2               			;reg $2181-$2183  -  WRAM address, no initialization required
000063r 2               
000063r 2               			;reg $4016-$4017  - serial JoyPad read registers, no need to initialize
000063r 2               
000063r 2               
000063r 2  9C 00 42       STZ $4200		;reg $4200  - disable timers, NMI,and auto-joyread
000066r 2               
000066r 2  A9 FF          LDA #$FF
000068r 2  8D 01 42       STA $4201		;reg $4201  - programmable I/O write port, initalize to allow reading at in-port
00006Br 2               
00006Br 2               			;regs $4202-$4203  - multiplication registers, no initialization required
00006Br 2               			;regs $4204-$4206  - division registers, no initialization required
00006Br 2               
00006Br 2               			;regs $4207-$4208  - Horizontal-IRQ timer setting, since we disabled this, it is OK to not init
00006Br 2               			;regs $4209-$420A  - Vertical-IRQ timer setting, since we disabled this, it is OK to not init
00006Br 2               
00006Br 2  9C 0B 42       STZ $420B		;reg $420B  - turn off all general DMA channels
00006Er 2  9C 0C 42       STZ $420C		;reg $420C  - turn off all H-MA channels
000071r 2               
000071r 2  9C 0D 42       STZ $420D		;reg $420D  - ROM access time to slow (2.68Mhz)
000074r 2               
000074r 2  AD 10 42       LDA $4210		;reg $4210  - NMI status, reading resets
000077r 2               
000077r 2               			;reg $4211  - IRQ status, no need to initialize
000077r 2               			;reg $4212  - H/V blank and JoyRead status, no need to initialize
000077r 2               			;reg $4213  - programmable I/O inport, no need to initialize
000077r 2               
000077r 2               			;reg $4214-$4215  - divide results, no need to initialize
000077r 2               			;reg $4216-$4217  - multiplication or remainder results, no need to initialize
000077r 2               
000077r 2               			;regs $4218-$421f  - JoyPad read registers, no need to initialize
000077r 2               
000077r 2               			;regs $4300-$437F
000077r 2               			;no need to intialize because DMA was disabled above
000077r 2               			;also, we're not sure what all of the registers do, so it is better to leave them at
000077r 2               			;their reset state value
000077r 2               
000077r 2  20 rr rr      JSR ClearVRAM      ;Reset VRAM
00007Ar 2                ; JSR ClearPalette   ;Reset colors
00007Ar 2               
00007Ar 2                 ;**** clear Sprite tables ********
00007Ar 2               
00007Ar 2  9C 02 21       STZ $2102	;sprites initialized to be off the screen, palette 0, character 0
00007Dr 2  9C 03 21       STZ $2103
000080r 2  A2 80 00       LDX #$0080
000083r 2  A9 F0          LDA #$F0
000085r 2               _Loop08:
000085r 2  8D 04 21       STA $2104	;set X = 240
000088r 2  8D 04 21       STA $2104	;set Y = 240
00008Br 2  9C 04 21       STZ $2104	;set character = $00
00008Er 2  9C 04 21       STZ $2104	;set priority=0, no flips
000091r 2  CA             DEX
000092r 2  D0 F1          BNE _Loop08
000094r 2               
000094r 2  A2 20 00       LDX #$0020
000097r 2               _Loop09:
000097r 2  9C 04 21       STZ $2104		;set size bit=0, x MSB = 0
00009Ar 2  CA             DEX
00009Br 2  D0 FA          BNE _Loop09
00009Dr 2               
00009Dr 2                 ;**** clear WRAM ********
00009Dr 2  9C 81 21       STZ $2181		;set WRAM address to $000000
0000A0r 2  9C 82 21       STZ $2182
0000A3r 2  9C 83 21       STZ $2183
0000A6r 2               
0000A6r 2  A2 08 80       LDX #$8008
0000A9r 2  8E 00 43       STX $4300         ;Set DMA mode to fixed source, BYTE to $2180
0000ACr 2  A2 rr rr       LDX #wram_fill_byte
0000AFr 2  8E 02 43       STX $4302         ;Set source offset
0000B2r 2  A9 rr          LDA #<.bank(wram_fill_byte)
0000B4r 2  8D 04 43       STA $4304         ;Set source bank
0000B7r 2  A2 00 00       LDX #$0000
0000BAr 2  8E 05 43       STX $4305         ;Set transfer size to 64k bytes
0000BDr 2  A9 01          LDA #$01
0000BFr 2  8D 0B 42       STA $420B         ;Initiate transfer
0000C2r 2               
0000C2r 2  A9 01          LDA #$01          ;now set the next 64k bytes
0000C4r 2  8D 0B 42       STA $420B         ;Initiate transfer
0000C7r 2               
0000C7r 2  4B             PHK			;make sure Data Bank = Program Bank
0000C8r 2  AB             PLB
0000C9r 2               
0000C9r 2  58             CLI			;enable interrupts again
0000CAr 2               
0000CAr 2  AE 72 43       LDX $4372  	;get our return address...
0000CDr 2  8E FD 1F       STX $1FFD
0000D0r 2  AD 74 43       LDA $4374
0000D3r 2  8D FF 1F       STA $1FFF
0000D6r 2  6B             RTL
0000D7r 2               
0000D7r 2               wram_fill_byte:
0000D7r 2  00           .byte $00
0000D8r 2               
0000D8r 2               ;----------------------------------------------------------------------------
0000D8r 2               ; ClearVRAM -- Sets every byte of VRAM to zero
0000D8r 2               ; In: None
0000D8r 2               ; Out: None
0000D8r 2               ; Modifies: flags
0000D8r 2               ;----------------------------------------------------------------------------
0000D8r 2               ClearVRAM:
0000D8r 2  48              pha
0000D9r 2  DA              phx
0000DAr 2  08              php
0000DBr 2               
0000DBr 2  C2 30           REP #$30		; mem/A = 8 bit, X/Y = 16 bit
0000DDr 2  E2 20           SEP #$20
0000DFr 2               
0000DFr 2  A9 80           LDA #$80
0000E1r 2  8D 15 21        STA $2115         ;Set VRAM port to word access
0000E4r 2  A2 09 18        LDX #$1809
0000E7r 2  8E 00 43        STX $4300         ;Set DMA mode to fixed source, WORD to $2118/9
0000EAr 2  A2 00 00        LDX #$0000
0000EDr 2  8E 16 21        STX $2116         ;Set VRAM port address to $0000
0000F0r 2  86 00           STX $0000         ;Set $00:0000 to $0000 (assumes scratchpad ram)
0000F2r 2  8E 02 43        STX $4302         ;Set source address to $xx:0000
0000F5r 2  A9 00           LDA #$00
0000F7r 2  8D 04 43        STA $4304         ;Set source bank to $00
0000FAr 2  A2 FF FF        LDX #$FFFF
0000FDr 2  8E 05 43        STX $4305         ;Set transfer size to 64k-1 bytes
000100r 2  A9 01           LDA #$01
000102r 2  8D 0B 42        STA $420B         ;Initiate transfer
000105r 2               
000105r 2  9C 19 21        STZ $2119         ;clear the last byte of the VRAM
000108r 2               
000108r 2  28              plp
000109r 2  FA              plx
00010Ar 2  68              pla
00010Br 2  60              RTS
00010Cr 2               
00010Cr 2               ;----------------------------------------------------------------------------
00010Cr 2               ; ClearPalette -- Reset all palette colors to zero
00010Cr 2               ; In: None
00010Cr 2               ; Out: None
00010Cr 2               ; Modifies: flags
00010Cr 2               ;----------------------------------------------------------------------------
00010Cr 2               ClearPalette:
00010Cr 2  DA              PHX
00010Dr 2  08              PHP
00010Er 2  C2 30           REP #$30		; mem/A = 8 bit, X/Y = 16 bit
000110r 2  E2 20           SEP #$20
000112r 2               
000112r 2  9C 21 21        STZ $2121
000115r 2  A2 00 01        LDX #$0100
000118r 2               ClearPaletteLoop:
000118r 2  9C 22 21        STZ $2122
00011Br 2  9C 22 21        STZ $2122
00011Er 2  CA              DEX
00011Fr 2  D0 F7           BNE ClearPaletteLoop
000121r 2               
000121r 2  28              PLP
000122r 2  FA              PLX
000123r 2  60              RTS
000124r 2               
000124r 2               
000124r 1               .include "constants.asm"
000124r 2               ;---oam pt 2 write masks---
000124r 2               
000124r 2               .define SPRITE3_MASK %00111111
000124r 2               .define SPRITE2_MASK %11001111
000124r 2               .define SPRITE1_MASK %11110011
000124r 2               .define SPRITE0_MASK %11111100
000124r 2               
000124r 2               ;oam mirror defines
000124r 2               .define OamMirror $400
000124r 2               .define Oam2Mirror $600
000124r 2               
000124r 2               .define BG2ScrollTable $620
000124r 2               ;object list format:
000124r 2               ; x pos (byte)
000124r 2               ; y pos (byte)
000124r 2               ; attributes (byte)
000124r 2               ; status (0=still, 1 = moving, 2 = ready to despawn, etc) (byte)
000124r 2               ; pointer to "handler" function
000124r 2               .define EntityList $630
000124r 2               .define TilemapMirror $700
000124r 2               .define TextQueue $B00
000124r 2               ;format:
000124r 2               ; address to write to (word)
000124r 2               ; text tile data
000124r 2               ; zero terminator (word)
000124r 2               
000124r 1               .include "variables.asm"
000124r 2               .segment "ZEROPAGE"
000000r 2  xx xx xx xx  scratchpad: .res 16 ;"local variables" for subroutines
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
000010r 2  xx xx        joypad: .res 2
000012r 2  xx xx        joypadBuf: .res 2 ;last frame's joypad input, useful for differentiating a press and a hold
000014r 2  xx xx        scrollX: .res 2
000016r 2  xx xx        scrollY: .res 2
000018r 2  xx xx        scroll2X: .res 2
00001Ar 2  xx           frameStatus: .res 1 ;0 if main loop is done executing
00001Br 2  xx           watchDog: .res 1 ;set to 0 at the start of main loop and incremented every vblank.
00001Cr 2                                ;if it doesn't get reset within 64 frames, assume the game's crashed
00001Cr 2               ;---scroll.asm---
00001Cr 2  xx xx        scrollColumn: .res 2 ;last scroll column loaded
00001Er 2  xx xx        scrollScreenAddr: .res 2 ;pointer to "screen" that you're loading tiles from
000020r 2  xx xx        scrollScreenNum: .res 2
000022r 2  xx xx        scrollMirrorPtr: .res 2
000024r 2  xx xx        scrollLock: .res 2 ;player x pos within screen that causes scrolling to lock
000026r 2  xx xx        rScrollLim: .res 2
000028r 2               
000028r 2               ;---text.asm---
000028r 2  xx xx        textQueueIndex: .res 2
00002Ar 2               
00002Ar 2               ;---player.asm---
00002Ar 2  xx xx xx xx  playerX: .res 4 ;16.16 fixed
00002Er 2  xx xx xx xx  playerY: .res 4
000032r 2  xx xx xx xx  playerXSpeed: .res 4
000036r 2  xx xx xx xx  playerYSpeed: .res 4
00003Ar 2  xx xx        playerSpriteX: .res 2
00003Cr 2  xx           playerTileNum: .res 1
00003Dr 2  xx           playerAnimTimer: .res 1
00003Er 2  xx           playerAnimMode: .res 1 ;16 bit to avoid constant accumulator size changing
00003Fr 2  xx           playerAttrs: .res 1
000040r 2  xx xx        playerState: .res 2
000042r 2  xx xx        movementState: .res 2
000044r 2               
000044r 2               ;---collision.asm---
000044r 2  xx xx xx xx  collisionX: .res 4
000048r 2  xx xx xx xx  collisionY: .res 4
00004Cr 2  xx xx xx xx  collisionXSpeed: .res 4
000050r 2  xx xx xx xx  collisionYSpeed: .res 4
000054r 2  xx xx        currBGTile: .res 2
000056r 2               
000056r 1               .include "macros.asm"
000056r 2               .macro LoadPalette source, colorIndex, numColors
000056r 2               ;parameters:
000056r 2               ;source, color to start on, number of colors to copy
000056r 2                   lda #colorIndex
000056r 2                   sta $2121       ; Start at START color
000056r 2                   lda #<.bank(source)        ; Using : before the parameter gets its bank.
000056r 2                   ldx #source         ; Not using : gets the offset address.
000056r 2                   ldy #(numColors * 2)   ; 2 bytes for every color
000056r 2                   jsr DMAPalette
000056r 2               .endmacro
000056r 2               
000056r 2               .macro LoadBlockToVRAM source, destination, size
000056r 2               ;parameters:
000056r 2               ;source, destination, size
000056r 2                   lda #$80
000056r 2                   sta $2115       ; Set VRAM transfer mode to word-access, increment by 1
000056r 2                   ldx #destination         ; DEST
000056r 2                   stx $2116       ; $2116: Word address for accessing VRAM.
000056r 2                   lda #.lobyte(.bank(source))        ; SRCBANK
000056r 2                   ldx #.loword(source)         ; SRCOFFSET
000056r 2                   ldy #size         ; SIZE
000056r 2                   jsr LoadVRAM
000056r 2               .endmacro
000056r 2               
000056r 2               .macro WRAMtoVRAM source, destination, size
000056r 2               	lda #$80
000056r 2               	sta $2115
000056r 2               	ldx #destination
000056r 2               	stx $2116 ;vram write cursor
000056r 2               	lda #$7e ; source bank, means this macro can only access first 64k of wram
000056r 2               	ldx #.loword(source)
000056r 2               	ldy #size
000056r 2               	jsr LoadVRAM
000056r 2               .endmacro
000056r 2               
000056r 2               .macro LoadBlockToWRAM source, destination, size
000056r 2               	ldx #.loword(source)
000056r 2               	stx $4302 ;source address
000056r 2               	lda #.lobyte(.bank(source))
000056r 2               	sta $4304 ;bank
000056r 2               	ldx #size
000056r 2               	stx $4305
000056r 2               	ldx #destination ; set wram transfer address
000056r 2               	stx $2181
000056r 2               	stz $2183 ;only accesses the first 64k, yolo
000056r 2               	lda #$80 ;dest = vram port
000056r 2               	sta $4301
000056r 2               	stz $4300 ; 1 byte transfer, auto-increment
000056r 2               	lda #$1
000056r 2               	sta $420b ;start transfer
000056r 2               .endmacro
000056r 2               
000056r 2               .macro SetHScroll hVal
000056r 2               ;parameter: mem address of horizontal scroll val
000056r 2               	rep #$20
000056r 2               	lda hVal
000056r 2               	sep #$20
000056r 2               	sta $210D	; BG1 horiz scroll
000056r 2               	xba
000056r 2               	sta $210D
000056r 2               .endmacro
000056r 2               
000056r 2               .macro SetVScroll vVal
000056r 2               ;parameter: mem address of vertical scroll val
000056r 2               	rep #$20
000056r 2               	lda vVal
000056r 2               	sep #$20
000056r 2               	sta $210E	; BG1 vert scroll
000056r 2               	xba
000056r 2               	sta $210E
000056r 2               .endmacro
000056r 2               
000056r 2               .macro SetMosaic level
000056r 2               ;parameter: mosaic level (0-15 dec, 0-f hex)
000056r 2               	lda level
000056r 2               	and #$F ;param %=15
000056r 2               	clc
000056r 2               	ror a
000056r 2               	ror a
000056r 2               	ror a
000056r 2               	ora #$1
000056r 2               	sta $2106
000056r 2               .endmacro
000056r 2               
000056r 2               .macro PositiveDiff val1, val2
000056r 2               ;puts the difference of val1 and val2 into a
000056r 2               	lda val1
000056r 2               	cmp val2
000056r 2               	bcs @Val1Greater
000056r 2               	sec
000056r 2               	lda val2
000056r 2               	sbc val1
000056r 2               	jmp @end
000056r 2               @Val1Greater:
000056r 2               	sec
000056r 2               	sbc val2
000056r 2               @end:
000056r 2               .endmacro
000056r 2               
000056r 2               .macro a16
000056r 2               	rep #$20
000056r 2               	.a16
000056r 2               .endmacro
000056r 2               
000056r 2               .macro a8
000056r 2               	sep #$20
000056r 2               	.a8
000056r 2               .endmacro
000056r 2               
000056r 2               .segment "CODE"
000124r 2               DMAPalette:
000124r 2               ;a- data bank
000124r 2               ;x- data offset
000124r 2               ;y- size of data
000124r 2               
000124r 2               ;processor status onto stack
000124r 2  8B           	phb
000125r 2  08           	php
000126r 2  8E 02 43     	stx $4302 ;address into dma 0 source register
000129r 2  8D 04 43     	sta $4304 ;bank into channel 0 bank register
00012Cr 2  8C 05 43     	sty $4305 ;number of bytes into channel 0 size
00012Fr 2  9C 00 43     	stz $4300 ;dma byte mode, increment by 1
000132r 2  A9 22        	lda #$22 ;$2122=color palette write
000134r 2  8D 01 43     	sta $4301
000137r 2  A9 01        	lda #$1
000139r 2  8D 0B 42     	sta $420B ;start transfer
00013Cr 2               
00013Cr 2  28           	plp
00013Dr 2  AB           	plb
00013Er 2  60           	rts
00013Fr 2               
00013Fr 2               LoadVRAM:
00013Fr 2               ;a- data bank
00013Fr 2               ;x- data offset
00013Fr 2               ;y- num of bytes to copy
00013Fr 2  8B           	phb
000140r 2  08               php         ; Preserve Registers
000141r 2  8E 02 43         stx $4302   ; Store Data offset into DMA source offset
000144r 2  8D 04 43         sta $4304   ; Store data Bank into DMA source bank
000147r 2  8C 05 43         sty $4305   ; Store size of data block
00014Ar 2               
00014Ar 2  A9 01            lda #$1
00014Cr 2  8D 00 43         sta $4300   ; Set DMA mode (word, normal increment)
00014Fr 2  A9 18            lda #$18    ; Set the destination register (VRAM write register)
000151r 2  8D 01 43         sta $4301
000154r 2  A9 01            lda #$1    ; Initiate DMA transfer (channel 1)
000156r 2  8D 0B 42     	sta $420B
000159r 2               
000159r 2  28               plp         ; restore registers
00015Ar 2  AB           	plb
00015Br 2  60               rts         ; return
00015Cr 2               
00015Cr 2               ClearMem:
00015Cr 2               ;x- amount of ram to clear
00015Cr 2               @ClearLoop:
00015Cr 2  74 00        	stz $0, x
00015Er 2  CA           	dex
00015Fr 2  D0 FB        	bne @ClearLoop
000161r 2  64 00        	stz $0
000163r 2  60           	rts
000164r 2               
000164r 2               
000164r 1               .include "sprites.asm"
000164r 2               spriteNum = $0
000164r 2               xPos = $1
000164r 2               yPos = $3
000164r 2               tileNum = $4
000164r 2               sprAttrs = $5
000164r 2               oam2Data = $6
000164r 2               oam2WriteIndex = $7
000164r 2               
000164r 2               
000164r 2               .macro LoadSprite sprite, tile, xOffset, yOffset, attributes
000164r 2               ;parameters: sprite num, pointer to x coord, pointer to y coord, pointer to tile num, attributes, big/small
000164r 2               ;shoutout to nintendo for making me go through all this bullshit, can't have
000164r 2               ; all the memory together or something sane
000164r 2               	a8
000164r 2               	lda sprite
000164r 2               	sta spriteNum
000164r 2               	a16
000164r 2               	lda xOffset
000164r 2               	sta xPos
000164r 2               	a8
000164r 2               	lda yOffset
000164r 2               	sta yPos
000164r 2               	lda tile
000164r 2               	sta tileNum
000164r 2               	lda attributes
000164r 2               	sta sprAttrs
000164r 2               	jsr SetOamMirror
000164r 2               	a16
000164r 2               .endmacro
000164r 2               
000164r 2               .segment "CODE"
000164r 2               InitSprites:
000164r 2  08           	php
000165r 2  A9 01        	lda #$1
000167r 2  A2 00 00     	ldx #$0
00016Ar 2               OamInitLoop: ;apparently just setting the sprites to $100 doesn't actually cause them to be removed from the scanline limit
00016Ar 2  9D 00 04     	sta OamMirror,x ;sets lower byte of every sprite's x pos to 1
00016Dr 2  E8           	inx
00016Er 2  E8           	inx
00016Fr 2  E8           	inx
000170r 2  E8           	inx
000171r 2  E0 00 02     	cpx #$200 ;$80 * 4
000174r 2  D0 F4        	bne OamInitLoop
000176r 2  A9 55        	lda #$55
000178r 2  A2 00 00     	ldx #$0
00017Br 2               Oam2InitLoop:
00017Br 2  9D 00 06     	sta Oam2Mirror,x
00017Er 2  E8           	inx
00017Fr 2  E0 20 00     	cpx #$20 ;size of oam pt 2
000182r 2  D0 F7        	bne Oam2InitLoop
000184r 2  28           	plp
000185r 2  60           	rts
000186r 2               
000186r 2               SetOamMirror: ;OAM handler function
000186r 2  A5 00        	lda spriteNum
000188r 2  EB           	xba
000189r 2  A9 00        	lda #$0 ;make sure top byte of a is 0
00018Br 2  EB           	xba
00018Cr 2  C2 20        	a16
00018Er 2  18           	clc
00018Fr 2  2A           	rol a ;we multiply by 4 because each sprite has 4 bytes of data in OAM table
000190r 2  2A           	rol a
000191r 2  AA           	tax
000192r 2  A5 01        	lda xPos
000194r 2  E2 20        	a8
000196r 2  9D 00 04     	sta OamMirror,x
000199r 2  EB           	xba ;high byte of sprite x position
00019Ar 2  29 01        	and #$1 ;SNES only cares about bit 9
00019Cr 2  85 06        	sta oam2Data ;data to write to OAM part 2
00019Er 2  E8           	inx
00019Fr 2  A5 03        	lda yPos
0001A1r 2  9D 00 04     	sta OamMirror,x
0001A4r 2  E8           	inx
0001A5r 2  A5 04        	lda tileNum
0001A7r 2  9D 00 04     	sta OamMirror,x
0001AAr 2  E8           	inx
0001ABr 2  A5 05        	lda sprAttrs
0001ADr 2  9D 00 04     	sta OamMirror,x
0001B0r 2               
0001B0r 2               	; lda size ;i don't care about size at the moment, might enable later if I do
0001B0r 2               	; and #$1 ;combine sprite size and msb of xpos
0001B0r 2               	; ror a
0001B0r 2               	; ora oam2Data
0001B0r 2               	; sta oam2Data
0001B0r 2  A5 00        	lda spriteNum
0001B2r 2  18           	clc
0001B3r 2  6A           	ror a ;4 sprites per oam table byte
0001B4r 2  6A           	ror a
0001B5r 2  29 7F        	and #$7F
0001B7r 2  85 07        	sta oam2WriteIndex
0001B9r 2               
0001B9r 2  A5 00        	lda spriteNum
0001BBr 2  29 03        	and #%00000011 ;only care if it's 0 to 3 since there's 4 bytes in OAM pt 2
0001BDr 2  F0 0B        	beq Sprite0 ;check where in the byte to place 1st x bit/sprite size
0001BFr 2  C9 01        	cmp #$1
0001C1r 2  F0 16        	beq Sprite1
0001C3r 2  C9 02        	cmp #$2
0001C5r 2  F0 26        	beq Sprite2
0001C7r 2  4C rr rr     	jmp Sprite3
0001CAr 2               
0001CAr 2               Sprite0:
0001CAr 2  A6 07        	ldx oam2WriteIndex
0001CCr 2  BD 00 06     	lda Oam2Mirror,x
0001CFr 2  29 FC        	and #SPRITE0_MASK
0001D1r 2  05 06        	ora oam2Data
0001D3r 2  9D 00 06     	sta Oam2Mirror,x
0001D6r 2  4C rr rr     	jmp EndBitStuff
0001D9r 2               
0001D9r 2               Sprite1:
0001D9r 2  18           	clc
0001DAr 2  26 06        	rol oam2Data
0001DCr 2  26 06        	rol oam2Data
0001DEr 2               
0001DEr 2  A6 07        	ldx oam2WriteIndex
0001E0r 2  BD 00 06     	lda Oam2Mirror,x
0001E3r 2  29 F3        	and #SPRITE1_MASK
0001E5r 2  05 06        	ora oam2Data
0001E7r 2  9D 00 06     	sta Oam2Mirror,x
0001EAr 2  4C rr rr     	jmp EndBitStuff
0001EDr 2               
0001EDr 2               Sprite2:
0001EDr 2  18           	clc
0001EEr 2  26 06        	rol oam2Data
0001F0r 2  26 06        	rol oam2Data
0001F2r 2  26 06        	rol oam2Data
0001F4r 2  26 06        	rol oam2Data
0001F6r 2               
0001F6r 2  A6 07        	ldx oam2WriteIndex
0001F8r 2  BD 00 06     	lda Oam2Mirror,x
0001FBr 2  29 CF        	and #SPRITE2_MASK
0001FDr 2  05 06        	ora oam2Data
0001FFr 2  9D 00 06     	sta Oam2Mirror,x
000202r 2  4C rr rr     	jmp EndBitStuff
000205r 2               
000205r 2               Sprite3:
000205r 2  18           	clc
000206r 2  26 06        	rol oam2Data
000208r 2  26 06        	rol oam2Data
00020Ar 2  26 06        	rol oam2Data
00020Cr 2  26 06        	rol oam2Data
00020Er 2  26 06        	rol oam2Data
000210r 2  26 06        	rol oam2Data
000212r 2               
000212r 2  A6 07        	ldx oam2WriteIndex
000214r 2  BD 00 06     	lda Oam2Mirror,x
000217r 2  29 3F        	and #SPRITE3_MASK
000219r 2  05 06        	ora oam2Data
00021Br 2  9D 00 06     	sta Oam2Mirror,x
00021Er 2               
00021Er 2               EndBitStuff:
00021Er 2  60           	rts
00021Fr 2               
00021Fr 2               
00021Fr 1               .include "text.asm"
00021Fr 2               .macro DrawText textAddr, xPos, yPos ;assumes a is 16 bits
00021Fr 2               	lda #textAddr
00021Fr 2               	sta $0
00021Fr 2               	lda xPos
00021Fr 2               	sta $2
00021Fr 2               	lda yPos
00021Fr 2               	jsr WriteString
00021Fr 2               .endmacro
00021Fr 2               
00021Fr 2               .macro DrawByte byteAddr, xPos, yPos ;assumes a is 16 bits
00021Fr 2               	lda byteAddr
00021Fr 2               	sta $0
00021Fr 2               	lda xPos
00021Fr 2               	sta $2
00021Fr 2               	lda yPos
00021Fr 2               	jsr WriteByte
00021Fr 2               .endmacro
00021Fr 2               
00021Fr 2               .macro DrawWord wordAddr, xPos, yPos
00021Fr 2               	lda wordAddr ;first byte
00021Fr 2               	xba
00021Fr 2               	sta $0
00021Fr 2               	lda xPos
00021Fr 2               	sta $2
00021Fr 2               	lda yPos
00021Fr 2               	jsr WriteByte
00021Fr 2               
00021Fr 2               	lda wordAddr
00021Fr 2               	sta $0
00021Fr 2               	lda xPos+2
00021Fr 2               	sta $2
00021Fr 2               	lda yPos
00021Fr 2               	jsr WriteByte
00021Fr 2               
00021Fr 2               .endmacro
00021Fr 2               
00021Fr 2               .segment "CODE"
00021Fr 2               
00021Fr 2               ;tile number = (asciiNum - $20)
00021Fr 2               
00021Fr 2               TextL0:
00021Fr 2               ;      01234567890123456789012345678901
00021Fr 2  48 69 74 20  .byte "Hit or miss, I guess they never",0
000223r 2  6F 72 20 6D  
000227r 2  69 73 73 2C  
00023Fr 2               TextL1:
00023Fr 2  6D 69 73 73  .byte "miss, huh? You got a boyfriend?",0
000243r 2  2C 20 68 75  
000247r 2  68 3F 20 59  
00025Fr 2               TextL2:
00025Fr 2  49 20 62 65  .byte "I bet he doesn't kiss ya! He gon",0
000263r 2  74 20 68 65  
000267r 2  20 64 6F 65  
000280r 2               TextL3:
000280r 2  66 69 6E 64  .byte "find another girl and he won't",0
000284r 2  20 61 6E 6F  
000288r 2  74 68 65 72  
00029Fr 2               TextL4:
00029Fr 2  6D 69 73 73  .byte "miss ya! He gon' skrrt and hit",0
0002A3r 2  20 79 61 21  
0002A7r 2  20 48 65 20  
0002BEr 2               TextL5:
0002BEr 2  74 68 65 20  .byte "the dab like Wiz Khalifa.",0
0002C2r 2  64 61 62 20  
0002C6r 2  6C 69 6B 65  
0002D8r 2               
0002D8r 2               
0002D8r 2               WriteString:
0002D8r 2  C2 20        	a16
0002DAr 2  A6 rr        	ldx textQueueIndex
0002DCr 2               
0002DCr 2  0A           	asl ;yPos (already in a) * 32 + xPos = tilemap pos to start writing at
0002DDr 2  0A           	asl
0002DEr 2  0A           	asl
0002DFr 2  0A           	asl
0002E0r 2  0A           	asl
0002E1r 2  18           	clc
0002E2r 2  65 02        	adc $2
0002E4r 2  18           	clc
0002E5r 2  69 00 4C     	adc #$4c00 ;text layer base addr
0002E8r 2  9D 00 0B     	sta TextQueue, x
0002EBr 2  E8           	inx
0002ECr 2  E8           	inx
0002EDr 2               
0002EDr 2  A9 00 00     	lda #$0
0002F0r 2  A0 00 00     	ldy #$0
0002F3r 2               
0002F3r 2               	AsciiLoop:
0002F3r 2  B1 00        	lda ($0), y
0002F5r 2  29 FF 00     	and #$ff ;limit to first byte
0002F8r 2  F0 0F        	beq EndAsciiLoop ;strings are null terminated
0002FAr 2  38           		sec
0002FBr 2  E9 20 00     		sbc #$20
0002FEr 2  09 00 20     		ora #$2000 ;max priority
000301r 2  9D 00 0B     		sta TextQueue, x
000304r 2               
000304r 2  E8           		inx ;destination- words so inc by 2
000305r 2  E8           		inx
000306r 2  C8           		iny ;source- bytes so inc by 1
000307r 2  80 EA        	bra AsciiLoop
000309r 2               	EndAsciiLoop:
000309r 2  9E 00 0B     	stz TextQueue, x ;zero-terminate data
00030Cr 2  E8           	inx
00030Dr 2  E8           	inx
00030Er 2  86 rr        	stx textQueueIndex ;update textQueueIndex
000310r 2               
000310r 2  60           	rts
000311r 2               
000311r 2               WriteByte:
000311r 2  C2 20        	a16
000313r 2  A6 rr        	ldx textQueueIndex
000315r 2               
000315r 2  0A           	asl ;yPos (already in a) * 32 + xPos = tilemap pos to start writing at
000316r 2  0A           	asl
000317r 2  0A           	asl
000318r 2  0A           	asl
000319r 2  0A           	asl
00031Ar 2  18           	clc
00031Br 2  65 02        	adc $2
00031Dr 2  18           	clc
00031Er 2  69 00 4C     	adc #$4c00 ;text layer addr
000321r 2  9D 00 0B     	sta TextQueue, x
000324r 2  E8           	inx
000325r 2  E8           	inx
000326r 2               
000326r 2  A5 00        	lda $0
000328r 2  29 F0 00     	and #$f0
00032Br 2  4A           	lsr
00032Cr 2  4A           	lsr
00032Dr 2  4A           	lsr
00032Er 2  4A           	lsr
00032Fr 2  C9 0A 00     	cmp #$a ;because of how ASCII works, you have to add #$10 to the value to get
000332r 2  B0 06        	bcs AddLettersN1 ;the ascii tile if it's between 0-9, but #$17 if it's between A-F
000334r 2  18           		clc
000335r 2  69 10 00     		adc #$10
000338r 2  80 04        		bra DoneAddN1
00033Ar 2               	AddLettersN1:
00033Ar 2  18           		clc
00033Br 2  69 17 00     		adc #$17
00033Er 2               	DoneAddN1:
00033Er 2  09 00 20     	ora #$2000
000341r 2  9D 00 0B     	sta TextQueue, x
000344r 2  E8           	inx
000345r 2  E8           	inx
000346r 2               	;repeat for second nybble
000346r 2  A5 00        	lda $0
000348r 2  29 0F 00     	and #$0f
00034Br 2  C9 0A 00     	cmp #$a
00034Er 2  B0 06        	bcs AddLettersN2
000350r 2  18           		clc
000351r 2  69 10 00     		adc #$10
000354r 2  80 04        		bra DoneAddN2
000356r 2               	AddLettersN2:
000356r 2  18           		clc
000357r 2  69 17 00     		adc #$17
00035Ar 2               	DoneAddN2:
00035Ar 2  09 00 20     	ora #$2000
00035Dr 2  9D 00 0B     	sta TextQueue, x
000360r 2  E8           	inx
000361r 2  E8           	inx
000362r 2  9E 00 0B     	stz TextQueue, x
000365r 2  E8           	inx
000366r 2  E8           	inx
000367r 2  86 rr        	stx textQueueIndex ;update textQueueIndex
000369r 2  60           	rts
00036Ar 2               
00036Ar 2               TransferTextQueue:
00036Ar 2  08           	php
00036Br 2  E2 20        	a8
00036Dr 2  A9 80        	lda #$80
00036Fr 2  8D 15 21     	sta $2115 ;VRAM transfer: words, inc by 1
000372r 2  C2 20        	a16
000374r 2  A2 00 00     	ldx #$0
000377r 2               	TextWriteLoop:
000377r 2  BD 00 0B     		lda TextQueue, x ;first word: destination address
00037Ar 2  F0 1B        		beq DoneTextWrite
00037Cr 2  9E 00 0B     		stz TextQueue, x ;erase queue as we go
00037Fr 2  8D 16 21     		sta $2116 ;VRAM address
000382r 2  E8           		inx
000383r 2  E8           		inx
000384r 2               		TextDataLoop:
000384r 2  BD 00 0B     			lda TextQueue, x
000387r 2  F0 0A        			beq DoneTextData
000389r 2  9E 00 0B     			stz TextQueue, x
00038Cr 2  8D 18 21     			sta $2118 ;VRAM write port
00038Fr 2  E8           			inx
000390r 2  E8           			inx
000391r 2  80 F1        			bra TextDataLoop
000393r 2               		DoneTextData:
000393r 2  E8           		inx
000394r 2  E8           		inx
000395r 2  80 E0        	bra TextWriteLoop
000397r 2               	DoneTextWrite:
000397r 2  64 rr        	stz textQueueIndex ;reset for next frame
000399r 2  28           	plp
00039Ar 2  60           	rts
00039Br 2               
00039Br 1               .include "crashhandler.asm"
00039Br 2               .segment "CODE"
00039Br 2               
00039Br 2               CrashHandler:
00039Br 2  9C 00 42     	stz PPUNMI
00039Er 2  C2 20        	a16
0003A0r 2  85 10        	sta $10 ;store register state
0003A2r 2  86 12        	stx $12
0003A4r 2  84 14        	sty $14
0003A6r 2  3B           	tsc
0003A7r 2  85 16        	sta $16 ;stack pointer
0003A9r 2  E2 20        	a8
0003ABr 2  AD 10 42     	lda NMISTATUS ;clear NMI in case we crashed during vblank
0003AEr 2  68           	pla
0003AFr 2  85 18        	sta $18 ;status register
0003B1r 2  68           	pla
0003B2r 2  85 1A        	sta $1a ;pc low
0003B4r 2  68           	pla
0003B5r 2  85 1C        	sta $1c ;pc high
0003B7r 2  68           	pla
0003B8r 2  85 1E        	sta $1e ;program bank
0003BAr 2  C2 20        	a16
0003BCr 2  A9 rr rr 85  	DrawText ErrorMessage, #$3, #$3
0003C0r 2  00 A9 03 00  
0003C4r 2  85 02 A9 03  
0003CCr 2  A9 rr rr 85  	DrawText ErrorMessage2, #$3, #$4
0003D0r 2  00 A9 03 00  
0003D4r 2  85 02 A9 04  
0003DCr 2  A9 rr rr 85  	DrawText Registers, #$3, #$6
0003E0r 2  00 A9 03 00  
0003E4r 2  85 02 A9 06  
0003ECr 2  A5 10 EB 85  	DrawWord $10, #$6, #$6 ;a register
0003F0r 2  00 A9 06 00  
0003F4r 2  85 02 A9 06  
00040Br 2  A5 12 EB 85  	DrawWord $12, #$e, #$6 ;x register
00040Fr 2  00 A9 0E 00  
000413r 2  85 02 A9 06  
00042Ar 2  A5 14 EB 85  	DrawWord $14, #$16, #$6 ;y register
00042Er 2  00 A9 16 00  
000432r 2  85 02 A9 06  
000449r 2  A9 rr rr 85  	DrawText PCLabel, #$3, #$7
00044Dr 2  00 A9 03 00  
000451r 2  85 02 A9 07  
000459r 2  A5 1E 85 00  	DrawByte $1e, #$7, #$7 ;PC data bank
00045Dr 2  A9 07 00 85  
000461r 2  02 A9 07 00  
000468r 2  A5 1A EB 85  	DrawWord $1a, #$a, #$7 ;program counter
00046Cr 2  00 A9 0A 00  
000470r 2  85 02 A9 07  
000487r 2  A5 16 EB 85  	DrawWord $16, #$16, #$7 ;stack pointer
00048Br 2  00 A9 16 00  
00048Fr 2  85 02 A9 07  
0004A6r 2  A9 rr rr 85  	DrawText StackLabel, #$3, #$9
0004AAr 2  00 A9 03 00  
0004AEr 2  85 02 A9 09  
0004B6r 2               	;stack row 1
0004B6r 2  AD F0 1F 85  	DrawByte $1ff0, #$3, #$a
0004BAr 2  00 A9 03 00  
0004BEr 2  85 02 A9 0A  
0004C6r 2  AD F1 1F 85  	DrawByte $1ff1, #$6, #$a
0004CAr 2  00 A9 06 00  
0004CEr 2  85 02 A9 0A  
0004D6r 2  AD F2 1F 85  	DrawByte $1ff2, #$9, #$a
0004DAr 2  00 A9 09 00  
0004DEr 2  85 02 A9 0A  
0004E6r 2  AD F3 1F 85  	DrawByte $1ff3, #$c, #$a
0004EAr 2  00 A9 0C 00  
0004EEr 2  85 02 A9 0A  
0004F6r 2  AD F4 1F 85  	DrawByte $1ff4, #$f, #$a
0004FAr 2  00 A9 0F 00  
0004FEr 2  85 02 A9 0A  
000506r 2  AD F5 1F 85  	DrawByte $1ff5, #$12, #$a
00050Ar 2  00 A9 12 00  
00050Er 2  85 02 A9 0A  
000516r 2  AD F6 1F 85  	DrawByte $1ff6, #$15, #$a
00051Ar 2  00 A9 15 00  
00051Er 2  85 02 A9 0A  
000526r 2  AD F7 1F 85  	DrawByte $1ff7, #$18, #$a
00052Ar 2  00 A9 18 00  
00052Er 2  85 02 A9 0A  
000536r 2               	;stack row 2
000536r 2  AD F8 1F 85  	DrawByte $1ff8, #$3, #$b
00053Ar 2  00 A9 03 00  
00053Er 2  85 02 A9 0B  
000546r 2  AD F9 1F 85  	DrawByte $1ff9, #$6, #$b
00054Ar 2  00 A9 06 00  
00054Er 2  85 02 A9 0B  
000556r 2  AD FA 1F 85  	DrawByte $1ffa, #$9, #$b
00055Ar 2  00 A9 09 00  
00055Er 2  85 02 A9 0B  
000566r 2  AD FB 1F 85  	DrawByte $1ffb, #$c, #$b
00056Ar 2  00 A9 0C 00  
00056Er 2  85 02 A9 0B  
000576r 2  AD FC 1F 85  	DrawByte $1ffc, #$f, #$b
00057Ar 2  00 A9 0F 00  
00057Er 2  85 02 A9 0B  
000586r 2  AD FD 1F 85  	DrawByte $1ffd, #$12, #$b
00058Ar 2  00 A9 12 00  
00058Er 2  85 02 A9 0B  
000596r 2  AD FE 1F 85  	DrawByte $1ffe, #$15, #$b
00059Ar 2  00 A9 15 00  
00059Er 2  85 02 A9 0B  
0005A6r 2  AD FF 1F 85  	DrawByte $1fff, #$18, #$b
0005AAr 2  00 A9 18 00  
0005AEr 2  85 02 A9 0B  
0005B6r 2               
0005B6r 2  E2 20        	a8
0005B8r 2  A9 80        	lda #FORCEBLANK
0005BAr 2  8D 00 21     	sta PPUBRIGHT ;force blank enabled
0005BDr 2               
0005BDr 2               	;----zerofill text layer-----
0005BDr 2  C2 20        	a16
0005BFr 2  A9 00 4C     	lda #$4c00 ;vram address to write to
0005C2r 2  8D 16 21     	sta $2116
0005C5r 2  E2 20        	a8
0005C7r 2  A9 80        	lda #$80
0005C9r 2  8D 15 21     	sta $2115 ;VRAM transfer: words, inc by 1
0005CCr 2  A9 09        	lda #$9 ;fixed a-bus word transfer
0005CEr 2  8D 00 43     	sta $4300
0005D1r 2  A9 18        	lda #$18 ;vram write port, $2118
0005D3r 2  8D 01 43     	sta $4301
0005D6r 2  C2 20        	a16
0005D8r 2  A9 rr rr     	lda #ClearWord
0005DBr 2  8D 02 43     	sta $4302 ;address to write from
0005DEr 2  A9 00 08     	lda #$800 ;# of bytes to write
0005E1r 2  8D 05 43     	sta $4305
0005E4r 2  E2 20        	a8
0005E6r 2  9C 04 43     	stz $4304 ;bank
0005E9r 2  A9 01        	lda #$1 ;start the transfer
0005EBr 2  8D 0B 42     	sta $420b
0005EEr 2               
0005EEr 2  A9 04            lda #%00000100 ;only enable bg3 (text layer)
0005F0r 2  8D 2C 21         sta BLENDMAIN
0005F3r 2               
0005F3r 2  20 rr rr     	jsr TransferTextQueue
0005F6r 2  9C 21 21     	stz $2121
0005F9r 2  A9 0F        	lda #$f
0005FBr 2  8D 22 21     	sta $2122
0005FEr 2  9C 22 21     	stz $2122
000601r 2  A9 0F        	lda #$f ;turn on ppu rendering, max brightness
000603r 2  8D 00 21     	sta PPUBRIGHT
000606r 2               
000606r 2               	ForeverLoop:
000606r 2  80 FE        		bra ForeverLoop
000608r 2               
000608r 2               ClearWord:
000608r 2  00 00        	.word $0
00060Ar 2               ErrorMessage:
00060Ar 2               ;          0123456789ABCDEF0123456789ABCDEF
00060Ar 2  54 68 65 20  	.byte "The programmer has a nap!",0
00060Er 2  70 72 6F 67  
000612r 2  72 61 6D 6D  
000624r 2               ErrorMessage2:
000624r 2  48 6F 6C 64  	.byte "Hold out! Programmer!",0
000628r 2  20 6F 75 74  
00062Cr 2  21 20 50 72  
00063Ar 2               Registers:
00063Ar 2  61 3A 20 23  	.byte "a: #### x: #### y: ####",0
00063Er 2  23 23 23 20  
000642r 2  78 3A 20 23  
000652r 2               PCLabel:
000652r 2  70 63 3A 20  	.byte "pc: ##:#### stack: ####",0
000656r 2  23 23 3A 23  
00065Ar 2  23 23 23 20  
00066Ar 2               StackLabel:
00066Ar 2  73 74 61 63  	.byte "stack (starting @ $1ff0):",0
00066Er 2  6B 20 28 73  
000672r 2  74 61 72 74  
000684r 2               
000684r 1               .include "tiles.asm"
000684r 2               .segment "CODE"
000684r 2               
000684r 2               TILE_HARD = $0 ; if player is ejected from tile
000684r 2               
000684r 2               TileAttrs: ;either "hard" aka eject or pointer to heightmap
000684r 2  00 00        .word TILE_HARD
000686r 2  00 00        .word TILE_HARD
000688r 2  rr rr        .word HeightMap4
00068Ar 2  rr rr        .word HeightMap6
00068Cr 2  rr rr        .word HeightMap8
00068Er 2               
00068Er 2               ;if tile has momentum, needs to be more than PLAYER_ACCEL or else weird stuff happens
00068Er 2               MomentumTable:
00068Er 2  00 00        .word $0
000690r 2  00 00        .word $0
000692r 2  00 60        .word $6000
000694r 2  00 60        .word $6000
000696r 2  00 44        .word $4400
000698r 2  00 44        .word $4400
00069Ar 2               
00069Ar 2               HeightMap4: ;height map for tile 4
00069Ar 2  01 00        .word $1
00069Cr 2  02 00        .word $2
00069Er 2  03 00        .word $3
0006A0r 2  04 00        .word $4
0006A2r 2  05 00        .word $5
0006A4r 2  06 00        .word $6
0006A6r 2  07 00        .word $7
0006A8r 2  08 00        .word $8
0006AAr 2  09 00        .word $9
0006ACr 2  0A 00        .word $a
0006AEr 2  0B 00        .word $b
0006B0r 2  0C 00        .word $c
0006B2r 2  0D 00        .word $d
0006B4r 2  0E 00        .word $e
0006B6r 2  0F 00        .word $f
0006B8r 2  10 00        .word $10
0006BAr 2               
0006BAr 2               HeightMap6:
0006BAr 2  01 00        .word $1
0006BCr 2  01 00        .word $1
0006BEr 2  02 00        .word $2
0006C0r 2  02 00        .word $2
0006C2r 2  03 00        .word $3
0006C4r 2  03 00        .word $3
0006C6r 2  04 00        .word $4
0006C8r 2  04 00        .word $4
0006CAr 2  05 00        .word $5
0006CCr 2  05 00        .word $5
0006CEr 2  06 00        .word $6
0006D0r 2  06 00        .word $6
0006D2r 2  07 00        .word $7
0006D4r 2  07 00        .word $7
0006D6r 2  08 00        .word $8
0006D8r 2  08 00        .word $8
0006DAr 2               
0006DAr 2               HeightMap8:
0006DAr 2  09 00        .word $9
0006DCr 2  09 00        .word $9
0006DEr 2  0A 00        .word $a
0006E0r 2  0A 00        .word $a
0006E2r 2  0B 00        .word $b
0006E4r 2  0B 00        .word $b
0006E6r 2  0C 00        .word $c
0006E8r 2  0C 00        .word $c
0006EAr 2  0D 00        .word $d
0006ECr 2  0D 00        .word $d
0006EEr 2  0E 00        .word $e
0006F0r 2  0E 00        .word $e
0006F2r 2  0F 00        .word $f
0006F4r 2  0F 00        .word $f
0006F6r 2  10 00        .word $10
0006F8r 2  10 00        .word $10
0006FAr 2               
0006FAr 1               .include "player.asm"
0006FAr 2               .segment "CODE"
0006FAr 2               
0006FAr 2               PLAYER_ACCEL = $4000 ;0.25 px
0006FAr 2               PLAYER_JUMP_SPEED = $fff8 ;-7
0006FAr 2               GRAVITY = $6fff ;~0.4px
0006FAr 2               
0006FAr 2               
0006FAr 2               MAX_PLAYER_SPEED = $3
0006FAr 2               MAX_SLOPE_SPEED = $4
0006FAr 2               PLAYER_STILL_TILE = $0
0006FAr 2               FIRST_PLAYER_TILE = $2
0006FAr 2               LAST_PLAYER_TILE = $8 ;horizontally
0006FAr 2               PLAYER_JUMPING_TILE = $E
0006FAr 2               PLAYER_TIMER_VAL = $6 ;animation timer
0006FAr 2               GROUND = $B0
0006FAr 2               
0006FAr 2               PLAYER_RIGHT_ATTRS = %00110000
0006FAr 2               PLAYER_LEFT_ATTRS =  %01110000
0006FAr 2               
0006FAr 2               PLAYER_WIDTH = $10
0006FAr 2               PLAYER_HEIGHT = $20
0006FAr 2               PLAYER_TOP = $9 ;offset from y pos to top of sprite
0006FAr 2               
0006FAr 2               .enum
0006FAr 2               STATE_DECEL
0006FAr 2               STATE_RIGHT_HELD
0006FAr 2               STATE_LEFT_HELD
0006FAr 2               .endenum
0006FAr 2               
0006FAr 2               .enum
0006FAr 2               MOVE_STATE_NORMAL
0006FAr 2               MOVE_STATE_JUMPING
0006FAr 2               MOVE_STATE_FALLING ;like jumping but without the jumping frame
0006FAr 2               MOVE_STATE_SLOPE ;when player is on slope
0006FAr 2               .endenum
0006FAr 2               
0006FAr 2               .enum
0006FAr 2               ANIM_MODE_ADD
0006FAr 2               ANIM_MODE_SUBTRACT
0006FAr 2               .endenum
0006FAr 2               
0006FAr 2               InitPlayer:
0006FAr 2  08           	php
0006FBr 2  E2 20        	a8
0006FDr 2  A9 B0        	lda #GROUND
0006FFr 2  85 rr        	sta playerY+2
000701r 2  A9 20        	lda #$20
000703r 2  85 rr        	sta playerX+2
000705r 2  85 rr        	sta playerSpriteX
000707r 2  A9 30        	lda #PLAYER_RIGHT_ATTRS
000709r 2  85 rr        	sta playerAttrs
00070Br 2  A9 02        	lda #FIRST_PLAYER_TILE
00070Dr 2  85 rr        	sta playerTileNum
00070Fr 2  28           	plp
000710r 2  60           	rts
000711r 2               
000711r 2               HandlePlayerMovement:
000711r 2  08           	php
000712r 2  C2 20        	a16
000714r 2  A5 rr        	lda joypad
000716r 2  89 00 01     	bit #KEY_RIGHT ;sets up player state based on joypad input
000719r 2  F0 10        	beq NotRight
00071Br 2  A9 01 00     		lda #STATE_RIGHT_HELD
00071Er 2  85 rr        		sta playerState
000720r 2  E2 20        		a8
000722r 2  A9 30        		lda #PLAYER_RIGHT_ATTRS
000724r 2  85 rr        		sta playerAttrs
000726r 2  C2 20        		a16
000728r 2  4C rr rr     		jmp EndStateAssign
00072Br 2               	NotRight:
00072Br 2  89 00 02     	bit #KEY_LEFT
00072Er 2  F0 10        	beq NotLeft
000730r 2  A9 02 00     		lda #STATE_LEFT_HELD
000733r 2  85 rr        		sta playerState
000735r 2  E2 20        		a8
000737r 2  A9 70        		lda #PLAYER_LEFT_ATTRS
000739r 2  85 rr        		sta playerAttrs
00073Br 2  C2 20        		a16
00073Dr 2  4C rr rr     		jmp EndStateAssign
000740r 2               	NotLeft:
000740r 2  A9 00 00     	lda #STATE_DECEL
000743r 2  85 rr        	sta playerState
000745r 2               
000745r 2               	EndStateAssign:
000745r 2               
000745r 2  A5 rr        	lda playerState
000747r 2  D0 03        	bne ModifySpeed
000749r 2  4C rr rr     		jmp Released
00074Cr 2               	ModifySpeed:
00074Cr 2  C9 01 00     	cmp #STATE_RIGHT_HELD
00074Fr 2  D0 1C        	bne RightNotHeld
000751r 2  A5 rr        		lda playerXSpeed+2		;if player speed is greater than max speed, don't apply acceleration
000753r 2  C9 03 00     		cmp #MAX_PLAYER_SPEED
000756r 2  30 03        		bmi @AccelPlayer
000758r 2  4C rr rr     			jmp AddSpeed
00075Br 2               		@AccelPlayer:
00075Br 2  A5 rr        			lda playerXSpeed
00075Dr 2  18           			clc
00075Er 2  69 00 40     			adc #PLAYER_ACCEL
000761r 2  85 rr        			sta playerXSpeed
000763r 2  A5 rr        			lda playerXSpeed+2
000765r 2  69 00 00     			adc #$0
000768r 2  85 rr        			sta playerXSpeed+2
00076Ar 2  4C rr rr     			jmp AddSpeed
00076Dr 2               	RightNotHeld:
00076Dr 2  C9 02 00     	cmp #STATE_LEFT_HELD
000770r 2  D0 1C        	bne LeftNotHeld
000772r 2  A5 rr        		lda playerXSpeed+2
000774r 2  C9 FD FF     		cmp #-(MAX_PLAYER_SPEED)
000777r 2  10 03        		bpl @AccelPlayer
000779r 2  4C rr rr     			jmp AddSpeed
00077Cr 2               		@AccelPlayer:
00077Cr 2  A5 rr        			lda playerXSpeed
00077Er 2  38           			sec
00077Fr 2  E9 00 40     			sbc #PLAYER_ACCEL
000782r 2  85 rr        			sta playerXSpeed
000784r 2  A5 rr        			lda playerXSpeed+2
000786r 2  E9 00 00     			sbc #$0
000789r 2  85 rr        			sta playerXSpeed+2
00078Br 2  4C rr rr     			jmp AddSpeed
00078Er 2               	LeftNotHeld:
00078Er 2               
00078Er 2               	Released:
00078Er 2  A5 rr        	lda playerXSpeed
000790r 2  D0 07        	bne PlayerMoving
000792r 2  A5 rr        	lda playerXSpeed+2
000794r 2  D0 03        	bne PlayerMoving
000796r 2  4C rr rr     	jmp PlayerStill
000799r 2               	PlayerMoving:
000799r 2  A5 rr        		lda playerXSpeed+2
00079Br 2  29 00 80     		and #$8000
00079Er 2  F0 1B        		beq DecelRight
0007A0r 2  A5 rr        			lda playerXSpeed ;going left, add speed until 0
0007A2r 2  18           			clc
0007A3r 2  69 00 40     			adc #PLAYER_ACCEL
0007A6r 2  85 rr        			sta playerXSpeed
0007A8r 2  A5 rr        			lda playerXSpeed+2
0007AAr 2  69 00 00     			adc #$0
0007ADr 2  85 rr        			sta playerXSpeed+2
0007AFr 2  29 00 80     			and #$8000
0007B2r 2  D0 04        			bne @NotBelowZero
0007B4r 2  64 rr        				stz playerXSpeed
0007B6r 2  64 rr        				stz playerXSpeed+2
0007B8r 2               		@NotBelowZero:
0007B8r 2  4C rr rr     			jmp AddSpeed
0007BBr 2               		DecelRight:
0007BBr 2  A5 rr        			lda playerXSpeed
0007BDr 2  38           			sec
0007BEr 2  E9 00 40     			sbc #PLAYER_ACCEL
0007C1r 2  85 rr        			sta playerXSpeed
0007C3r 2  A5 rr        			lda playerXSpeed+2
0007C5r 2  E9 00 00     			sbc #$0
0007C8r 2  85 rr        			sta playerXSpeed+2
0007CAr 2  29 00 80     			and #$8000
0007CDr 2  F0 04        			beq @NotBelowZero
0007CFr 2  64 rr        				stz playerXSpeed
0007D1r 2  64 rr        				stz playerXSpeed+2
0007D3r 2               			@NotBelowZero:
0007D3r 2               
0007D3r 2               	AddSpeed:
0007D3r 2  C6 rr        	dec playerAnimTimer
0007D5r 2  A5 rr        	lda playerX
0007D7r 2  18           	clc
0007D8r 2  65 rr        	adc playerXSpeed
0007DAr 2  85 rr        	sta playerX
0007DCr 2  A5 rr        	lda playerX+2
0007DEr 2  65 rr        	adc playerXSpeed+2
0007E0r 2  85 rr        	sta playerX+2
0007E2r 2  80 10        	bra CheckJump
0007E4r 2               
0007E4r 2               	PlayerStill:
0007E4r 2  E2 20        	a8 ;if not pressing any buttons, reset tile and animation timer
0007E6r 2  A9 00        	lda #PLAYER_STILL_TILE
0007E8r 2  85 rr        	sta playerTileNum
0007EAr 2  A9 06        	lda #PLAYER_TIMER_VAL
0007ECr 2  85 rr        	sta playerAnimTimer
0007EEr 2  A9 00        	lda #ANIM_MODE_ADD
0007F0r 2  85 rr        	sta playerAnimMode
0007F2r 2  C2 20        	a16
0007F4r 2               	EndModifySpeed:
0007F4r 2               
0007F4r 2               	CheckJump:
0007F4r 2  A5 rr        	lda joypad
0007F6r 2  89 00 80     	bit #KEY_B
0007F9r 2  F0 24        	beq DontStartJump
0007FBr 2  A5 rr        	lda joypadBuf ;if holding down B from last jump, don't start jumping again
0007FDr 2  89 00 80     	bit #KEY_B
000800r 2  D0 33        	bne NotRising
000802r 2  A5 rr        		lda movementState
000804r 2  C9 01 00     		cmp #MOVE_STATE_JUMPING
000807r 2  F0 2C        		beq NotRising ;don't want player jumping in air
000809r 2  C9 02 00     		cmp #MOVE_STATE_FALLING
00080Cr 2  F0 27        		beq NotRising
00080Er 2  A9 01 00     			lda #MOVE_STATE_JUMPING
000811r 2  85 rr        			sta movementState
000813r 2  A9 F8 FF     			lda #PLAYER_JUMP_SPEED
000816r 2  85 rr        			sta playerYSpeed+2
000818r 2  A9 0E 00     			lda #PLAYER_JUMPING_TILE
00081Br 2  85 rr        			sta playerTileNum
00081Dr 2  80 16        			bra NotRising
00081Fr 2               			; dec playerY+2
00081Fr 2               	DontStartJump:
00081Fr 2  A5 rr        	lda playerYSpeed+2
000821r 2  29 00 80     	and #$8000
000824r 2  F0 0F        	beq NotRising ;if player is rising and let go of jump button, add a big ass number to speed to make them
000826r 2  A5 rr        		lda playerYSpeed ;fall faster
000828r 2  18           		clc
000829r 2  69 00 B0     		adc #$B000
00082Cr 2  85 rr        		sta playerYSpeed
00082Er 2  A5 rr        		lda playerYSpeed+2
000830r 2  69 00 00     		adc #$0
000833r 2  85 rr        		sta playerYSpeed+2
000835r 2               	NotRising:
000835r 2               
000835r 2  A5 rr        	lda movementState
000837r 2  C9 01 00     	cmp #MOVE_STATE_JUMPING
00083Ar 2  D0 07        	bne NoJumpingSprite ;switch to jumping sprite when jumping
00083Cr 2  A9 0E 00     		lda #PLAYER_JUMPING_TILE
00083Fr 2  85 rr        		sta playerTileNum
000841r 2  80 2D        		bra DoneAnim
000843r 2               	NoJumpingSprite:
000843r 2               
000843r 2  E2 20        	a8
000845r 2  A5 rr        	lda playerAnimTimer ;is timer zero?
000847r 2  D0 27        	bne DoneAnim
000849r 2  A9 06        		lda #PLAYER_TIMER_VAL
00084Br 2  85 rr        		sta playerAnimTimer
00084Dr 2  A5 rr        		lda playerAnimMode
00084Fr 2  D0 11        		bne AnimSubtract
000851r 2  A5 rr        			lda playerTileNum ;add to tile nim
000853r 2  1A           			ina
000854r 2  1A           			ina
000855r 2  85 rr        			sta playerTileNum
000857r 2  C9 08        			cmp #LAST_PLAYER_TILE ;if up to last tile, go to subtract mode
000859r 2  D0 15        			bne DoneAnim
00085Br 2  A9 01        				lda #ANIM_MODE_SUBTRACT
00085Dr 2  85 rr        				sta playerAnimMode
00085Fr 2  4C rr rr     				jmp DoneAnim
000862r 2               		AnimSubtract: ;subtract from tile num
000862r 2  A5 rr        			lda playerTileNum
000864r 2  3A           			dea
000865r 2  3A           			dea
000866r 2  85 rr        			sta playerTileNum
000868r 2  C9 02        			cmp #FIRST_PLAYER_TILE
00086Ar 2  D0 04        			bne DoneAnim
00086Cr 2  A9 00        				lda #ANIM_MODE_ADD
00086Er 2  85 rr        				sta playerAnimMode
000870r 2               	DoneAnim:
000870r 2               
000870r 2  28           	plp
000871r 2  60           	rts
000872r 2               
000872r 2               
000872r 2               
000872r 1               .include "collision.asm"
000872r 2               .segment "CODE"
000872r 2               
000872r 2               HandleCollision:
000872r 2               .scope
000872r 2               
000872r 2  C2 20        	a16
000874r 2  08           	php
000875r 2               
000875r 2  A5 rr        	lda collisionXSpeed+2
000877r 2  29 00 80     	and #$8000
00087Ar 2  F0 05        	beq CheckRightCollision
00087Cr 2  20 rr rr     		jsr HandleXCollisionL ;going left
00087Fr 2  80 03        		bra EndCheckCollision
000881r 2               	CheckRightCollision:
000881r 2  20 rr rr     		jsr HandleXCollisionR
000884r 2               	EndCheckCollision:
000884r 2               
000884r 2  A5 rr        	lda movementState ;eject vertically to the next tile when walking off a slope
000886r 2  C9 03 00     	cmp #MOVE_STATE_SLOPE
000889r 2  D0 1F        	bne @NotOnSlope
00088Br 2  20 rr rr     		jsr CheckYCollisionD ;if on a non-slope tile and was on a slope
00088Er 2  F0 1A        		beq @NotOnSlope
000890r 2  AA           		tax
000891r 2  BD rr rr     		lda TileAttrs, x
000894r 2  D0 14        		bne @NotOnSlope
000896r 2  A9 00 00     			lda #MOVE_STATE_NORMAL
000899r 2  85 rr        			sta movementState
00089Br 2               			@EjectLoop: ;vertical eject
00089Br 2  C6 rr        				dec collisionY+2
00089Dr 2  20 rr rr     				jsr CheckYCollisionD
0008A0r 2  F0 08        				beq @NotOnSlope
0008A2r 2  AA           				tax
0008A3r 2  BD rr rr     				lda TileAttrs, x
0008A6r 2  D0 02        				bne @NotOnSlope
0008A8r 2  80 F1        			bra @EjectLoop
0008AAr 2               	@NotOnSlope:
0008AAr 2               
0008AAr 2  A5 rr        	lda movementState
0008ACr 2  C9 01 00     	cmp #MOVE_STATE_JUMPING
0008AFr 2  F0 24        	beq OnGround
0008B1r 2  C9 02 00     	cmp #MOVE_STATE_FALLING
0008B4r 2  F0 1F        	beq OnGround
0008B6r 2  20 rr rr     		jsr CheckYCollisionD
0008B9r 2  F0 15        		beq StartFall
0008BBr 2  AA           			tax
0008BCr 2  BD rr rr     			lda TileAttrs, x
0008BFr 2  D0 02        			bne SlopeInsertLoop
0008C1r 2  80 12        		bra OnGround
0008C3r 2               			SlopeInsertLoop: ;if on a slope tile, insert into ground until touching a non-slope tile
0008C3r 2  E6 rr        				inc collisionY+2
0008C5r 2  20 rr rr     				jsr CheckYCollisionD
0008C8r 2  AA           				tax
0008C9r 2  BD rr rr     				lda TileAttrs, x
0008CCr 2  F0 07        				beq OnGround
0008CEr 2  80 F3        			bra SlopeInsertLoop
0008D0r 2               		StartFall:
0008D0r 2  A9 02 00     			lda #MOVE_STATE_FALLING
0008D3r 2  85 rr        			sta movementState
0008D5r 2               	OnGround:
0008D5r 2  20 rr rr     	jsr HandleSlopeCollision
0008D8r 2               
0008D8r 2  A5 rr        	lda movementState
0008DAr 2  C9 01 00     	cmp #MOVE_STATE_JUMPING
0008DDr 2  F0 08        	beq Jumping
0008DFr 2  C9 02 00     	cmp #MOVE_STATE_FALLING
0008E2r 2  F0 03        	beq Jumping
0008E4r 2  4C rr rr     	jmp NotJumping
0008E7r 2               	Jumping:
0008E7r 2  A5 rr        		lda collisionYSpeed
0008E9r 2  18           		clc
0008EAr 2  69 FF 6F     		adc #GRAVITY
0008EDr 2  85 rr        		sta collisionYSpeed
0008EFr 2  A5 rr        		lda collisionYSpeed+2
0008F1r 2  69 00 00     		adc #$0
0008F4r 2  85 rr        		sta collisionYSpeed+2
0008F6r 2  A5 rr        		lda collisionY
0008F8r 2  18           		clc
0008F9r 2  65 rr        		adc collisionYSpeed
0008FBr 2  85 rr        		sta collisionY
0008FDr 2  A5 rr        		lda collisionY+2
0008FFr 2  65 rr        		adc collisionYSpeed+2
000901r 2  85 rr        		sta collisionY+2
000903r 2               		UEjectLoop:
000903r 2  20 rr rr     		jsr CheckYCollisionU
000906r 2  F0 09        		beq NoCollisionU
000908r 2  64 rr        			stz collisionYSpeed
00090Ar 2  64 rr        			stz collisionYSpeed+2
00090Cr 2  E6 rr        			inc collisionY+2
00090Er 2  4C rr rr     			jmp UEjectLoop
000911r 2               		NoCollisionU:
000911r 2  A5 rr        		lda collisionYSpeed+2 ;if player isn't falling, don't check down collision
000913r 2  29 00 80     		and #$8000
000916r 2  D0 03        		bne NotJumping
000918r 2  20 rr rr     		jsr HandleYCollisionD
00091Br 2               	NotJumping:
00091Br 2               
00091Br 2  28           	plp
00091Cr 2  60           	rts
00091Dr 2               
00091Dr 2               HandleXCollisionL:
00091Dr 2  A5 rr        	lda movementState ;no wall collision if on slope
00091Fr 2  C9 03 00     	cmp #MOVE_STATE_SLOPE
000922r 2  F0 24        	beq NoCollisionL
000924r 2  20 rr rr     	jsr CheckXCollisionL
000927r 2  F0 1F        	beq NoCollisionL
000929r 2  AA           	tax
00092Ar 2  BD rr rr     	lda TileAttrs, x
00092Dr 2  D0 19        	bne NoCollisionL
00092Fr 2  64 rr        		stz collisionXSpeed
000931r 2  64 rr        		stz collisionXSpeed+2
000933r 2  64 rr        		stz collisionX
000935r 2  80 0B        		bra :+
000937r 2               		LEjectLoop:
000937r 2  20 rr rr     		jsr CheckXCollisionL
00093Ar 2  F0 0A        		beq DoneLEject
00093Cr 2  AA           			tax
00093Dr 2  BD rr rr     			lda TileAttrs, x
000940r 2  D0 06        			bne NoCollisionL
000942r 2  E6 rr        		:	inc collisionX+2
000944r 2  80 F1        			bra LEjectLoop
000946r 2               		DoneLEject:
000946r 2  C6 rr        		dec collisionX+2
000948r 2               	NoCollisionL:
000948r 2  60           	rts
000949r 2               
000949r 2               HandleXCollisionR:
000949r 2  A5 rr        	lda movementState
00094Br 2  C9 03 00     	cmp #MOVE_STATE_SLOPE
00094Er 2  F0 24        	beq NoCollisionR
000950r 2  20 rr rr     	jsr CheckXCollisionR
000953r 2  F0 1F        	beq NoCollisionR
000955r 2  AA           	tax
000956r 2  BD rr rr     	lda TileAttrs, x
000959r 2  D0 19        	bne NoCollisionR
00095Br 2  64 rr        		stz collisionXSpeed
00095Dr 2  64 rr        		stz collisionXSpeed+2
00095Fr 2  64 rr        		stz collisionX
000961r 2  80 0B        		bra :+
000963r 2               		REjectLoop:
000963r 2  20 rr rr     		jsr CheckXCollisionR
000966r 2  F0 0A        		beq DoneREject
000968r 2  AA           			tax
000969r 2  BD rr rr     			lda TileAttrs, x
00096Cr 2  D0 06        			bne NoCollisionR
00096Er 2  C6 rr        		:	dec collisionX+2
000970r 2  80 F1        			bra REjectLoop
000972r 2               		DoneREject:
000972r 2  E6 rr        		inc collisionX+2
000974r 2               		; jsr CheckXCollisionR
000974r 2               		; beq NoCollisionR
000974r 2               		; tax
000974r 2               		; lda TileAttrs, x ;tile attributes table in tiles.asm
000974r 2               		; bne NoCollisionR ;non-zero: "soft" tile
000974r 2               			; stz collisionXSpeed
000974r 2               			; stz collisionXSpeed+2
000974r 2               			; dec collisionX+2
000974r 2               			; bra HandleXCollisionR
000974r 2               	NoCollisionR:
000974r 2  60           	rts
000975r 2               
000975r 2               
000975r 2               HandleYCollisionD:
000975r 2  20 rr rr     	jsr CheckYCollisionD ;0 = sprite in air
000978r 2  F0 20        	beq NotInGround
00097Ar 2               
00097Ar 2               	; tax
00097Ar 2               	; lda TileAttrs, x
00097Ar 2               	; beq NormalEject
00097Ar 2               	; jmp HandleSlopeCollision
00097Ar 2               	NormalEject:
00097Ar 2  64 rr        		stz collisionYSpeed
00097Cr 2  64 rr        		stz collisionYSpeed+2
00097Er 2  64 rr        		stz collisionY
000980r 2  A9 00 00     		lda #MOVE_STATE_NORMAL
000983r 2  85 rr        		sta movementState
000985r 2  E2 20        		a8
000987r 2               		; lda #PLAYER_STILL_TILE
000987r 2               		; sta playerTileNum
000987r 2               		; lda #PLAYER_TIMER_VAL
000987r 2               		; sta playerAnimTimer
000987r 2               		; lda #ANIM_MODE_ADD
000987r 2               		; sta playerAnimMode
000987r 2  C2 20        		a16
000989r 2               		YEjectLoop:
000989r 2  C6 rr        			dec collisionY+2
00098Br 2  20 rr rr     			jsr CheckYCollisionD
00098Er 2  F0 08        			beq EjectedFromGround
000990r 2  AA           			tax ;don't eject from ground if it's a slope tile
000991r 2  BD rr rr     			lda TileAttrs, x
000994r 2  D0 02        			bne EjectedFromGround
000996r 2  80 F1        		bra YEjectLoop
000998r 2               		EjectedFromGround:
000998r 2  E6 rr        			inc collisionY+2
00099Ar 2               	NotInGround:
00099Ar 2  60           	rts
00099Br 2               
00099Br 2               	;collisionY = ((collisionY + PLAYER_HEIGHT-1) & $FFF0) - (tileLut, (middle of sprite x & $F)) - $10
00099Br 2               HandleSlopeCollision:
00099Br 2  A5 rr        	lda movementState
00099Dr 2  C9 01 00     	cmp #MOVE_STATE_JUMPING
0009A0r 2  F0 7C        	beq NotOnSlope
0009A2r 2  20 rr rr     	jsr CheckCollisionC
0009A5r 2  AA           	tax
0009A6r 2  BD rr rr     	lda TileAttrs, x
0009A9r 2  F0 73        	beq NotOnSlope
0009ABr 2  85 04        		sta $4 ;location of height LUT for that block
0009ADr 2  A5 rr        		lda currBGTile
0009AFr 2  29 00 40     		and #$4000
0009B2r 2  D0 09        		bne SubXCalc
0009B4r 2  A5 00        			lda $0 ;x value of middle of sprite
0009B6r 2  29 0F 00     			and #$000f
0009B9r 2  0A           			asl ;words->bytes
0009BAr 2  A8           			tay
0009BBr 2  80 0F        			bra EndXCalc
0009BDr 2               		SubXCalc:
0009BDr 2  A5 00        			lda $0 ;x value of middle of sprite
0009BFr 2  29 0F 00     			and #$000f
0009C2r 2  85 00        			sta $0
0009C4r 2  A9 0F 00     			lda #$f ;if it's been mirrored, start looking at height LUT from the end of the tile
0009C7r 2  38           			sec
0009C8r 2  E5 00        			sbc $0
0009CAr 2  0A           			asl ;words->bytes
0009CBr 2  A8           			tay
0009CCr 2               		EndXCalc:
0009CCr 2  B1 04        		lda ($4), y
0009CEr 2  85 00        		sta $0 ;value to bump up y position by
0009D0r 2  A5 02        		lda $2 ;tile where sprite's feet are
0009D2r 2  29 F0 FF     		and #$fff0
0009D5r 2  38           		sec
0009D6r 2  E5 00        		sbc $0
0009D8r 2  38           		sec
0009D9r 2  E9 10 00     		sbc #$10
0009DCr 2  85 rr        		sta collisionY+2
0009DEr 2  A9 03 00     		lda #MOVE_STATE_SLOPE
0009E1r 2  85 rr        		sta movementState
0009E3r 2               
0009E3r 2  A5 rr        		lda currBGTile
0009E5r 2  29 00 40     		and #$4000 ;has tile been mirrored?
0009E8r 2  F0 18        		beq @SubtractMomentum
0009EAr 2  A5 rr        			lda collisionXSpeed
0009ECr 2  18           			clc
0009EDr 2  7D rr rr     			adc MomentumTable, x
0009F0r 2  85 rr        			sta collisionXSpeed
0009F2r 2  A5 rr        			lda collisionXSpeed+2
0009F4r 2  69 00 00     			adc #$0
0009F7r 2  C9 04 00     			cmp #MAX_SLOPE_SPEED
0009FAr 2  D0 02        			bne @DontCapAddSpeed
0009FCr 2  64 rr        				stz collisionXSpeed
0009FEr 2               			@DontCapAddSpeed:
0009FEr 2  85 rr        			sta collisionXSpeed+2
000A00r 2  80 1C        			bra NotOnSlope
000A02r 2               		@SubtractMomentum:
000A02r 2  A5 rr        			lda collisionXSpeed
000A04r 2  38           			sec
000A05r 2  FD rr rr     			sbc MomentumTable, x
000A08r 2  85 rr        			sta collisionXSpeed
000A0Ar 2  A5 rr        			lda collisionXSpeed+2
000A0Cr 2  E9 00 00     			sbc #$0
000A0Fr 2  C9 FB FF     			cmp #-(MAX_SLOPE_SPEED+1)
000A12r 2  D0 08        			bne @DontCapSubSpeed
000A14r 2  A9 FF FF     				lda #$ffff
000A17r 2  85 rr        				sta collisionXSpeed
000A19r 2  A9 FB FF     				lda #-(MAX_SLOPE_SPEED+1)
000A1Cr 2               			@DontCapSubSpeed:
000A1Cr 2  85 rr        			sta collisionXSpeed+2
000A1Er 2               	NotOnSlope:
000A1Er 2  60           	rts
000A1Fr 2               
000A1Fr 2               CheckXCollisionL: ;for when player is moving left
000A1Fr 2  A5 rr        	lda collisionX+2
000A21r 2  85 00        	sta $0
000A23r 2  A5 rr        	lda collisionY+2
000A25r 2  18           	clc
000A26r 2  69 1F 00     	adc #PLAYER_HEIGHT-1
000A29r 2  85 02        	sta $2
000A2Br 2  4C rr rr     	jmp CheckCollision
000A2Er 2               
000A2Er 2               CheckXCollisionR: ;when player is moving right
000A2Er 2  A5 rr        	lda collisionX+2
000A30r 2  18           	clc
000A31r 2  69 10 00     	adc #PLAYER_WIDTH
000A34r 2  85 00        	sta $0
000A36r 2  A5 rr        	lda collisionY+2
000A38r 2  18           	clc
000A39r 2  69 1F 00     	adc #PLAYER_HEIGHT-1
000A3Cr 2  85 02        	sta $2
000A3Er 2  4C rr rr     	jmp CheckCollision
000A41r 2               
000A41r 2               ;center collision -> left collision -> right collision
000A41r 2               CheckYCollisionD:
000A41r 2  A5 rr        	lda collisionX+2 ;1. check for bottom-center collision
000A43r 2  18           	clc
000A44r 2  69 08 00     	adc #PLAYER_WIDTH/2
000A47r 2  85 00        	sta $0
000A49r 2  A5 rr        	lda collisionY+2
000A4Br 2  18           	clc
000A4Cr 2  69 21 00     	adc #PLAYER_HEIGHT+1
000A4Fr 2  85 02        	sta $2
000A51r 2  20 rr rr     	jsr CheckCollision
000A54r 2  D0 14        	bne @EndCheck ;if center hard collision, exit routine
000A56r 2               
000A56r 2  A5 rr        	lda collisionX+2 ;2. check for bottom-left collision
000A58r 2  85 00        	sta $0
000A5Ar 2  20 rr rr     	jsr CheckCollision
000A5Dr 2  D0 0B        	bne @EndCheck
000A5Fr 2               
000A5Fr 2  A5 rr        	lda collisionX+2 ;3. check for bottom-right collision
000A61r 2  18           	clc
000A62r 2  69 10 00     	adc #PLAYER_WIDTH
000A65r 2  85 00        	sta $0
000A67r 2  20 rr rr     	jsr CheckCollision
000A6Ar 2               	@EndCheck:
000A6Ar 2  60           	rts
000A6Br 2               
000A6Br 2               CheckYCollisionU: ;when player is moving up
000A6Br 2  A5 rr        	lda collisionX+2 ;1. check for bottom-center collision
000A6Dr 2  18           	clc
000A6Er 2  69 08 00     	adc #PLAYER_WIDTH/2
000A71r 2  85 00        	sta $0
000A73r 2  A5 rr        	lda collisionY+2
000A75r 2  18           	clc
000A76r 2  69 0B 00     	adc #PLAYER_TOP+2
000A79r 2  85 02        	sta $2
000A7Br 2  20 rr rr     	jsr CheckCollision
000A7Er 2  D0 14        	bne @EndCheck ;if center collision, exit routine
000A80r 2               
000A80r 2  A5 rr        	lda collisionX+2 ;2. check for bottom-left collision
000A82r 2  85 00        	sta $0
000A84r 2  20 rr rr     	jsr CheckCollision
000A87r 2  D0 0B        	bne @EndCheck
000A89r 2               
000A89r 2  A5 rr        	lda collisionX+2 ;3. check for bottom-right collision
000A8Br 2  18           	clc
000A8Cr 2  69 10 00     	adc #PLAYER_WIDTH
000A8Fr 2  85 00        	sta $0
000A91r 2  20 rr rr     	jsr CheckCollision
000A94r 2               	@EndCheck:
000A94r 2  60           	rts
000A95r 2               
000A95r 2               CheckCollisionC: ;look at the center of the bottom of the player
000A95r 2  A5 rr        	lda collisionX+2
000A97r 2  18           	clc
000A98r 2  69 08 00     	adc #(PLAYER_WIDTH/2)
000A9Br 2  85 00        	sta $0
000A9Dr 2  A5 rr        	lda collisionY+2
000A9Fr 2  18           	clc
000AA0r 2  69 1F 00     	adc #PLAYER_HEIGHT-1
000AA3r 2  85 02        	sta $2
000AA5r 2               
000AA5r 2               CheckCollision:
000AA5r 2  A5 00        	lda $0 ;divide by 16
000AA7r 2  29 FF 01     	and #$1ff
000AAAr 2  4A           	lsr
000AABr 2  4A           	lsr
000AACr 2  4A           	lsr
000AADr 2  4A           	lsr
000AAEr 2  85 rr        	sta currBGTile
000AB0r 2  A5 02        	lda $2 ;dividing y tile by 16 and then multiplying by 32 since tilemap's 32x32
000AB2r 2  18           	clc
000AB3r 2  65 rr        	adc scrollY
000AB5r 2  29 F0 FF     	and #$fff0	  ;is the same as removing last nibble and shifting left once
000AB8r 2  2A           	rol
000AB9r 2  18           	clc
000ABAr 2  65 rr        	adc currBGTile
000ABCr 2  2A           	rol ;words->bytes
000ABDr 2  AA           	tax
000ABEr 2  BD 00 07     	lda TilemapMirror, x
000AC1r 2  48           	pha
000AC2r 2  29 FF 43     	and #$43ff ;just get the 9 bit tile number and the x flip bit
000AC5r 2  85 rr        	sta currBGTile
000AC7r 2  68           	pla
000AC8r 2  29 FF 03     	and #$3ff
000ACBr 2  60           	rts
000ACCr 2               
000ACCr 2               .endscope
000ACCr 2               
000ACCr 1               .include "scroll.asm"
000ACCr 2               .segment "CODE"
000ACCr 2               ;2 way scrolling code (eventually)
000ACCr 2               
000ACCr 2               sourceAddr = $0
000ACCr 2               destAddr = $2
000ACCr 2               columnNum = $4
000ACCr 2               
000ACCr 2               InitScroll:
000ACCr 2  A9 rr rr     	lda #BGTilemap ;address of first offscreen column
000ACFr 2  85 rr        	sta scrollScreenAddr
000AD1r 2               
000AD1r 2  F4 02 00     	pea $0002
000AD4r 2  AB           	plb
000AD5r 2  AD rr rr     	lda BGRightLim
000AD8r 2  85 rr        	sta rScrollLim
000ADAr 2  AB           	plb
000ADBr 2               
000ADBr 2  60           	rts
000ADCr 2               
000ADCr 2               HandleScroll:
000ADCr 2  08           	php
000ADDr 2  C2 20        	a16
000ADFr 2  A5 rr        	lda playerX+2
000AE1r 2  C9 80 00     	cmp #$80 ; if playerX < $80
000AE4r 2  F0 02        	beq LockL
000AE6r 2  B0 06        	bcs NoLockL
000AE8r 2               	LockL:
000AE8r 2  85 rr        		sta playerSpriteX ;spriteX = playerX
000AEAr 2  64 rr        		stz scrollX ;scrollX = 0
000AECr 2  80 2A        		bra EndSetScroll
000AEEr 2               	NoLockL:
000AEEr 2               
000AEEr 2  A5 rr        	lda playerX+2
000AF0r 2  C5 rr        	cmp rScrollLim ;if playerX > rScrollLim
000AF2r 2  90 17        	bcc NoLockR
000AF4r 2  38           		sec ;playerSpriteX = playerX - rScrollLim + #$80 (middle of screen)
000AF5r 2  E5 rr        		sbc rScrollLim
000AF7r 2  18           		clc
000AF8r 2  69 80 00     		adc #$80
000AFBr 2  85 rr        		sta playerSpriteX
000AFDr 2               
000AFDr 2  A5 rr        		lda rScrollLim ;scrollX + rScrollLim - #$80 & #$3ff
000AFFr 2  38           		sec
000B00r 2  E9 80 00     		sbc #$80
000B03r 2  29 FF 03     		and #$3ff
000B06r 2  85 rr        		sta scrollX
000B08r 2  4C rr rr     		jmp EndHandleScroll ;since we're locked, don't need to scroll further
000B0Br 2               	NoLockR:
000B0Br 2               
000B0Br 2  A5 rr        	lda playerX+2 ;else, keep sprite centered, do scrolling normally
000B0Dr 2  38           	sec
000B0Er 2  E9 80 00     	sbc #$80
000B11r 2  85 rr        	sta scrollX
000B13r 2  A9 80 00     	lda #$80
000B16r 2  85 rr        	sta playerSpriteX
000B18r 2               	EndSetScroll:
000B18r 2               
000B18r 2  A5 rr        	lda playerXSpeed
000B1Ar 2  D0 06        	bne NotZero ;if player's not moving, don't have to worry about scroll
000B1Cr 2  A5 rr        	lda playerXSpeed+2
000B1Er 2  D0 02        	bne NotZero
000B20r 2  80 44        	bra DoneMovementTests
000B22r 2               
000B22r 2               	NotZero:
000B22r 2  A5 rr        	lda playerXSpeed+2
000B24r 2  29 00 80     	and #$8000
000B27r 2  F0 1E        	beq MovingRight
000B29r 2               	;if going left and scroll & 1f goes up, that means you wrapped (so should change screen addy)
000B29r 2               	;same if going right and scroll & 1f goes down
000B29r 2               	MovingLeft:
000B29r 2  A5 rr        	lda scrollX
000B2Br 2  4A           	lsr
000B2Cr 2  4A           	lsr
000B2Dr 2  4A           	lsr
000B2Er 2  4A           	lsr ;leftmost onscreen column
000B2Fr 2  3A           	dec a ;first offscreen column to the left
000B30r 2  29 1F 00     	and #$1f
000B33r 2  C5 rr        	cmp scrollColumn
000B35r 2  F0 57        	beq EndHandleScroll ; if it's the same, don't have to do anything
000B37r 2  85 rr        	sta scrollColumn
000B39r 2  90 2B        	bcc DoneMovementTests ;if it's less, normal screen movement
000B3Br 2  A5 rr        		lda scrollScreenAddr
000B3Dr 2  38           		sec
000B3Er 2  E9 80 03     		sbc #$380 ;32 columns, 14 rows, 1 word per tile
000B41r 2  85 rr        		sta scrollScreenAddr
000B43r 2  C6 rr        		dec scrollScreenNum
000B45r 2  80 1F        		bra DoneMovementTests
000B47r 2               
000B47r 2               	MovingRight:
000B47r 2  A5 rr        	lda scrollX
000B49r 2  4A           	lsr
000B4Ar 2  4A           	lsr
000B4Br 2  4A           	lsr
000B4Cr 2  4A           	lsr ;leftmost tile column on screen
000B4Dr 2  18           	clc
000B4Er 2  69 11 00     	adc #$11 ;first offscreen tile
000B51r 2  29 1F 00     	and #$1f
000B54r 2  C5 rr        	cmp scrollColumn ;beyond a new scroll boundary?
000B56r 2  F0 36        	beq EndHandleScroll ;same? don't do anything
000B58r 2  85 rr        	sta scrollColumn
000B5Ar 2  B0 0A        	bcs DoneMovementTests ;greater? tile pos didn't wrap
000B5Cr 2  A5 rr        		lda scrollScreenAddr ;otherwise, you've reached a new screen
000B5Er 2  18           		clc
000B5Fr 2  69 80 03     		adc #$380 ;32 columns, 14 rows, 1 word per tile
000B62r 2  85 rr        		sta scrollScreenAddr
000B64r 2  E6 rr        		inc scrollScreenNum
000B66r 2               	NotOnScreenBoundary:
000B66r 2               
000B66r 2               	DoneMovementTests:
000B66r 2  A5 rr        		lda scrollColumn
000B68r 2  0A           		asl ;words->bytes
000B69r 2  48           		pha ;>
000B6Ar 2  18           		clc
000B6Br 2  65 rr        		adc scrollScreenAddr
000B6Dr 2  85 00        		sta sourceAddr
000B6Fr 2  68           		pla ;<
000B70r 2  18           		clc
000B71r 2  69 00 07     		adc #TilemapMirror
000B74r 2  85 rr        		sta scrollMirrorPtr
000B76r 2  A2 0E 00     		ldx #$e ;number of tiles to copy
000B79r 2  A0 00 00     		ldy #$0
000B7Cr 2  F4 02 00     		pea $0002 ;bank with map data: $2 return bank: $0
000B7Fr 2               							;doesn't use immediate syntax for some reason
000B7Fr 2  AB           		plb ;load $2 from stack
000B80r 2               		@CopyLoop:
000B80r 2  B1 00        			lda (sourceAddr), y
000B82r 2  91 rr        			sta (scrollMirrorPtr), y
000B84r 2  98           			tya
000B85r 2  18           			clc
000B86r 2  69 40 00     			adc #$40
000B89r 2  A8           			tay
000B8Ar 2  CA           			dex
000B8Br 2  D0 F3        			bne @CopyLoop
000B8Dr 2  AB           		plb ;load $0 from stack
000B8Er 2               	EndHandleScroll:
000B8Er 2  28           	plp
000B8Fr 2  60           	rts
000B90r 2               
000B90r 2               VramScrollCopy: ;run during vblank if there's new tile data to copy
000B90r 2  E2 20        	a8
000B92r 2  A9 81        	lda #$81 ;increment vram access by 64 bytes
000B94r 2  8D 15 21     	sta PPUCTRL
000B97r 2  C2 20        	a16
000B99r 2               	; lda scrollColumn
000B99r 2               	; asl
000B99r 2               	; clc
000B99r 2               	; adc #TilemapMirror ;copy from tilemap mirror to real tilemap
000B99r 2               	; sta sourceAddr
000B99r 2               
000B99r 2  A5 rr        	lda scrollColumn
000B9Br 2  8D 16 21     	sta PPUADDR ;set up where to write to in VRAM
000B9Er 2  A2 0E 00     	ldx #$e ;number of tiles to copy
000BA1r 2  A0 00 00     	ldy #$0
000BA4r 2               	@CopyLoop:
000BA4r 2  B1 rr        		lda (scrollMirrorPtr), y
000BA6r 2  8D 18 21     		sta PPUDATA
000BA9r 2  98           		tya
000BAAr 2  18           		clc
000BABr 2  69 40 00     		adc #$40
000BAEr 2  A8           		tay
000BAFr 2  CA           		dex
000BB0r 2  D0 F2        		bne @CopyLoop
000BB2r 2  64 rr        	stz scrollMirrorPtr ;how I mark that the tile column has been copied already
000BB4r 2  E2 20        	a8
000BB6r 2  60           	rts
000BB7r 2               
000BB7r 2               
000BB7r 1               .include "art.asm"
000BB7r 2               .segment "BANK2"
000000r 2               FontPalette:
000000r 2  00 00 FF 7F  	.INCBIN ".\art\font.clr"
000004r 2  00 00 00 00  
000008r 2               FontTiles:
000008r 2  00 00 00 00  	.INCBIN ".\art\font.pic"
00000Cr 2  00 00 00 00  
000010r 2  00 00 00 00  
000608r 2               
000608r 2               PlayerPalette:
000608r 2  00 00 C0 00  	.INCBIN ".\art\player.clr"
00060Cr 2  26 1B 0C 00  
000610r 2  9F 1A FF 7F  
000628r 2               PlayerTiles:
000628r 2  00 00 00 00  	.INCBIN ".\art\player.pic"
00062Cr 2  00 00 00 00  
000630r 2  00 00 00 00  
001628r 2               
001628r 2               BGPalette:
001628r 2  00 00 FF 7F  	.INCBIN ".\art\bgtiles.clr"
00162Cr 2  05 4D 93 7B  
001630r 2  A1 71 3F 16  
001648r 2               BGTiles:
001648r 2  00 00 00 00  	.incbin ".\art\bgtiles.pic"
00164Cr 2  00 00 00 00  
001650r 2  00 00 00 00  
001A48r 2               
001A48r 2               BG2Palette:
001A48r 2  00 00 01 6D  	.INCBIN ".\art\bg2tiles.clr"
001A4Cr 2  87 6E A3 48  
001A50r 2  A1 71 C5 0D  
001A68r 2               BG2Tiles:
001A68r 2  00 00 00 00  	.incbin ".\art\bg2tiles.pic"
001A6Cr 2  00 00 00 00  
001A70r 2  00 00 00 00  
001C68r 2               
001C68r 2               BGRightLim:
001C68r 2  00 06        	.word $600 ;player X to lock at
001C6Ar 2               
001C6Ar 2               BGTilemap:
001C6Ar 2  02 00 00 00  	.incbin ".\tools\snesconv\out.bin"
001C6Er 2  00 00 00 00  
001C72r 2  00 00 00 00  
00386Ar 2               
00386Ar 2               BG2Tilemap:
00386Ar 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
00386Er 2  00 00 00 00  
003872r 2  00 00 00 00  
0038AAr 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
0038AEr 2  00 00 00 00  
0038B2r 2  00 00 00 00  
0038EAr 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
0038EEr 2  00 00 00 00  
0038F2r 2  00 00 00 00  
00392Ar 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
00392Er 2  00 00 00 00  
003932r 2  00 00 00 00  
00396Ar 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
00396Er 2  00 00 00 00  
003972r 2  00 00 00 00  
0039AAr 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
0039AEr 2  00 00 00 00  
0039B2r 2  00 00 00 00  
0039EAr 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
0039EEr 2  00 00 00 00  
0039F2r 2  00 00 00 00  
003A2Ar 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003A2Er 2  00 00 00 00  
003A32r 2  00 00 00 00  
003A6Ar 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003A6Er 2  00 00 00 00  
003A72r 2  00 00 00 00  
003AAAr 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003AAEr 2  00 00 00 00  
003AB2r 2  00 00 00 00  
003AEAr 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003AEEr 2  00 00 00 00  
003AF2r 2  00 00 00 00  
003B2Ar 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003B2Er 2  00 00 00 00  
003B32r 2  00 00 00 00  
003B6Ar 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003B6Er 2  00 00 00 00  
003B72r 2  00 00 00 00  
003BAAr 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003BAEr 2  00 00 00 00  
003BB2r 2  00 00 00 00  
003BEAr 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003BEEr 2  00 00 00 00  
003BF2r 2  00 00 00 00  
003C2Ar 2  00 00 00 00  	.word $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
003C2Er 2  00 00 00 00  
003C32r 2  00 00 00 00  
003C6Ar 2  01 00 02 00  	.word $1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4
003C6Er 2  03 00 04 00  
003C72r 2  01 00 02 00  
003CAAr 2  05 00 06 00  	.word $5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8
003CAEr 2  07 00 08 00  
003CB2r 2  05 00 06 00  
003CEAr 2  01 00 02 00  	.word $1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4
003CEEr 2  03 00 04 00  
003CF2r 2  01 00 02 00  
003D2Ar 2  05 00 06 00  	.word $5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8
003D2Er 2  07 00 08 00  
003D32r 2  05 00 06 00  
003D6Ar 2  01 00 02 00  	.word $1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4
003D6Er 2  03 00 04 00  
003D72r 2  01 00 02 00  
003DAAr 2  05 00 06 00  	.word $5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8
003DAEr 2  07 00 08 00  
003DB2r 2  05 00 06 00  
003DEAr 2  01 00 02 00  	.word $1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4
003DEEr 2  03 00 04 00  
003DF2r 2  01 00 02 00  
003E2Ar 2  05 00 06 00  	.word $5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8
003E2Er 2  07 00 08 00  
003E32r 2  05 00 06 00  
003E6Ar 2  01 00 02 00  	.word $1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4
003E6Er 2  03 00 04 00  
003E72r 2  01 00 02 00  
003EAAr 2  05 00 06 00  	.word $5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8
003EAEr 2  07 00 08 00  
003EB2r 2  05 00 06 00  
003EEAr 2  01 00 02 00  	.word $1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4
003EEEr 2  03 00 04 00  
003EF2r 2  01 00 02 00  
003F2Ar 2  05 00 06 00  	.word $5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8
003F2Er 2  07 00 08 00  
003F32r 2  05 00 06 00  
003F6Ar 2  01 00 02 00  	.word $1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4
003F6Er 2  03 00 04 00  
003F72r 2  01 00 02 00  
003FAAr 2  05 00 06 00  	.word $5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8
003FAEr 2  07 00 08 00  
003FB2r 2  05 00 06 00  
003FEAr 2  01 00 02 00  	.word $1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4,$1,$2,$3,$4
003FEEr 2  03 00 04 00  
003FF2r 2  01 00 02 00  
00402Ar 2  05 00 06 00  	.word $5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8,$5,$6,$7,$8
00402Er 2  07 00 08 00  
004032r 2  05 00 06 00  
00406Ar 2               
00406Ar 2               
00406Ar 1               .include "sound.asm"
00406Ar 2               .segment "BANK1"
000000r 2               
000000r 2               SPCPrg:
000000r 2  20 CD EF BD  	.incbin ".\sound\sound.bin"
000004r 2  E8 2C C4 F2  
000008r 2  E8 00 C4 F3  
003ACAr 2               SPCPrgEnd:
003ACAr 2               
003ACAr 2               SPC_LENGTH = SPCPrgEnd-SPCPrg
003ACAr 2               NUM_SPC_BLOCKS = (SPC_LENGTH / 256) + 1
003ACAr 2               copyAddr = $0 ;address to copy to (word)
003ACAr 2               copyIndex = $2 ;index within one block (byte)
003ACAr 2               blockIndex = $3 ;what block's being copied (byte)
003ACAr 2               kick = $4 ;current "kick" val
003ACAr 2               
003ACAr 2               LoadSPC:
003ACAr 2  08           	php
003ACBr 2  C2 20        	a16
003ACDr 2  A9 3B 00     	lda #NUM_SPC_BLOCKS
003AD0r 2  A9 00 02     	lda #$200
003AD3r 2  85 00        	sta copyAddr ;set up copy address
003AD5r 2  64 03        	stz blockIndex
003AD7r 2  E2 20        	a8
003AD9r 2  A9 CC        	lda #$cc ;starting kick val
003ADBr 2  85 04        	sta kick
003ADDr 2               
003ADDr 2               WaitForInit:
003ADDr 2  AD 40 21     	lda $2140
003AE0r 2  C9 AA        	cmp #$aa ;spc sets reg 0 to aa after it inits
003AE2r 2  D0 F9        	bne WaitForInit
003AE4r 2               
003AE4r 2               CopyLoop:
003AE4r 2  C2 20        	a16
003AE6r 2  A5 00        	lda copyAddr
003AE8r 2  8D 42 21     	sta $2142 ;write destination address
003AEBr 2  18           	clc
003AECr 2  69 00 01     	adc #$100
003AEFr 2  85 00        	sta copyAddr
003AF1r 2  E2 20        	a8
003AF3r 2               
003AF3r 2  A9 01        	lda #$1
003AF5r 2  8D 41 21     	sta $2141 ;write command
003AF8r 2  A5 04        	lda kick
003AFAr 2  8D 40 21     	sta $2140 ;"enable"
003AFDr 2               WaitForAck: ;spc returns kick when it's ready to write
003AFDr 2  AD 40 21     	lda $2140
003B00r 2  C5 04        	cmp kick
003B02r 2  D0 F9        	bne WaitForAck
003B04r 2               
003B04r 2               CopyBlock: ;copies blocks of 256 bytes
003B04r 2  C2 20        	a16
003B06r 2  A5 02        	lda copyIndex ;because blockIndex is next to copyIndex in memory hopefully
003B08r 2  AA           	tax	;this will get the address (look at me, so smart for making blocks 256 bytes)
003B09r 2  E2 20        	a8
003B0Br 2  BF rr rr rr  	lda f:SPCPrg,x ;specify bank
003B0Fr 2  8D 41 21     	sta $2141
003B12r 2  A5 02        	lda copyIndex
003B14r 2  8D 40 21     	sta $2140
003B17r 2               
003B17r 2               WaitReceive:
003B17r 2  CD 40 21     	cmp $2140 ;spc mirrors count after receiving data
003B1Ar 2  D0 FB        	bne WaitReceive
003B1Cr 2  1A           	inc a
003B1Dr 2  85 02        	sta copyIndex
003B1Fr 2  C9 00        	cmp #$00 ;256 bytes in a block
003B21r 2  D0 E1        	bne CopyBlock
003B23r 2               
003B23r 2  E6 03        	inc blockIndex
003B25r 2  A5 04        	lda kick
003B27r 2  18           	clc
003B28r 2  69 02        	adc #$2
003B2Ar 2  29 7F        	and #$7f ;kick=previous kick "+2 to 127" -ninty
003B2Cr 2  85 04        	sta kick
003B2Er 2  A5 03        	lda blockIndex
003B30r 2  C9 3B        	cmp #NUM_SPC_BLOCKS
003B32r 2  D0 B0        	bne CopyLoop
003B34r 2               
003B34r 2  C2 20        	a16
003B36r 2  A9 00 02     	lda #$200 ;entry point
003B39r 2  8D 42 21     	sta $2142
003B3Cr 2  E2 20        	a8
003B3Er 2  9C 41 21     	stz $2141 ;start command
003B41r 2  A5 04        	lda kick
003B43r 2  8D 40 21     	sta $2140
003B46r 2  A2 06 00     	ldx #$6
003B49r 2               @ClrLoop:
003B49r 2  74 00        	stz $0,x
003B4Br 2  CA           	dex
003B4Cr 2  D0 FB        	bne @ClrLoop
003B4Er 2  28           	plp
003B4Fr 2  6B           	rtl
003B50r 2               
003B50r 1               
003B50r 1               .segment "CODE"
000BB7r 1               
000BB7r 1               Reset:
000BB7r 1  78 18 FB C2  	InitSNES
000BBBr 1  38 A2 FF 1F  
000BBFr 1  9A 22 rr rr  
000BC6r 1  22 rr rr rr  	jsl LoadSPC
000BCAr 1  A9 00 8D 21  	LoadPalette BGPalette, $0, $10
000BCEr 1  21 A9 rr A2  
000BD2r 1  rr rr A0 20  
000BDAr 1  A9 10 8D 21  	LoadPalette BG2Palette, $10, $10
000BDEr 1  21 A9 rr A2  
000BE2r 1  rr rr A0 20  
000BEAr 1  A9 20 8D 21  	LoadPalette FontPalette, $20, $4
000BEEr 1  21 A9 rr A2  
000BF2r 1  rr rr A0 08  
000BFAr 1  A9 80 8D 21      LoadPalette PlayerPalette, $80, $10
000BFEr 1  21 A9 rr A2  
000C02r 1  rr rr A0 20  
000C0Ar 1               	; Load Tile data to VRAM
000C0Ar 1  A9 80 8D 15  	LoadBlockToVRAM BGTilemap, $0, $400
000C0Er 1  21 A2 00 00  
000C12r 1  8E 16 21 A9  
000C20r 1  A2 rr rr 8E  	LoadBlockToWRAM BGTilemap, TilemapMirror, $380
000C24r 1  02 43 A9 rr  
000C28r 1  8D 04 43 A2  
000C47r 1  A9 80 8D 15      LoadBlockToVRAM BGTiles, $1000, $400
000C4Br 1  21 A2 00 10  
000C4Fr 1  8E 16 21 A9  
000C5Dr 1               
000C5Dr 1  A9 80 8D 15  	LoadBlockToVRAM BG2Tilemap, $2000, $800
000C61r 1  21 A2 00 20  
000C65r 1  8E 16 21 A9  
000C73r 1  A9 80 8D 15  	LoadBlockToVRAM BG2Tiles, $3000, $200 ;8 tiles, 4bpp
000C77r 1  21 A2 00 30  
000C7Br 1  8E 16 21 A9  
000C89r 1               
000C89r 1  A9 80 8D 15  	LoadBlockToVRAM FontTiles, $4000, $600
000C8Dr 1  21 A2 00 40  
000C91r 1  8E 16 21 A9  
000C9Fr 1  A9 80 8D 15  	LoadBlockToVRAM PlayerTiles, $6000, $1000
000CA3r 1  21 A2 00 60  
000CA7r 1  8E 16 21 A9  
000CB5r 1                   ; Setup Video modes and other stuff, then turn on the screen
000CB5r 1  20 rr rr         jsr SetupVideo
000CB8r 1               
000CB8r 1  20 rr rr     	jsr InitSprites
000CBBr 1               
000CBBr 1               	; a16
000CBBr 1               	; DrawText TextL0, #$0, #$1
000CBBr 1               	; DrawText TextL1, #$0, #$2
000CBBr 1               	; DrawText TextL2, #$0, #$3
000CBBr 1               	; DrawText TextL3, #$0, #$4
000CBBr 1               	; DrawText TextL4, #$0, #$5
000CBBr 1               	; DrawText TextL5, #$4, #$6
000CBBr 1               	; a8
000CBBr 1               
000CBBr 1               	WaitStartFrame:
000CBBr 1  AD 37 21     	lda $2137 ;latches h/v counter
000CBEr 1  AD 3D 21     	lda $213d
000CC1r 1  D0 F8        	bne WaitStartFrame ;if not at the start of a frame, don't continue
000CC3r 1               
000CC3r 1  AD 10 42     	lda $4210
000CC6r 1  A9 81        	lda #VBLANK_NMI | AUTOREAD
000CC8r 1  8D 00 42     	sta PPUNMI ;enable vblank interrupt and joypad read
000CCBr 1  AD 10 42     	lda $4210
000CCEr 1               
000CCEr 1  C2 20        	a16
000CD0r 1  64 rr        	stz scrollX
000CD2r 1  64 rr        	stz scrollY
000CD4r 1               
000CD4r 1  20 rr rr     	jsr InitPlayer
000CD7r 1  20 rr rr     	jsr InitScroll
000CDAr 1               
000CDAr 1               MainLoop:
000CDAr 1  E2 20        	a8
000CDCr 1  E6 rr        	inc frameStatus ;how we check if the program's done executing
000CDEr 1  64 rr        	stz watchDog
000CE0r 1  C2 20        	a16
000CE2r 1  AD 18 42     	lda JOY1CUR ;p1 joypad read address
000CE5r 1  85 rr        	sta joypad
000CE7r 1  20 rr rr     	jsr HandlePlayerMovement
000CEAr 1               
000CEAr 1  A2 rr rr     	ldx #playerX ;source
000CEDr 1  A0 rr rr     	ldy #collisionX ;destination
000CF0r 1  A9 15 00     	lda #$15 ;number of bytes to copy - 1
000CF3r 1  54 00 00     	mvn $0, $0
000CF6r 1               
000CF6r 1  20 rr rr     	jsr HandleCollision
000CF9r 1               
000CF9r 1  A2 rr rr     	ldx #collisionX
000CFCr 1  A0 rr rr     	ldy #playerX
000CFFr 1  A9 15 00     	lda #$15
000D02r 1  54 00 00     	mvn $0, $0
000D05r 1               
000D05r 1  20 rr rr     	jsr HandleScroll
000D08r 1               
000D08r 1  E2 20 A9 00  	LoadSprite #$0, playerTileNum, playerSpriteX, playerY+2, playerAttrs
000D0Cr 1  85 00 C2 20  
000D10r 1  A5 rr 85 01  
000D27r 1  A5 rr        	lda playerY+2
000D29r 1  18           	clc
000D2Ar 1  69 10 00     	adc #$10
000D2Dr 1  85 0A        	sta $a
000D2Fr 1  A5 rr        	lda playerTileNum
000D31r 1  18           	clc
000D32r 1  69 20 00     	adc #$20
000D35r 1  85 0C        	sta $c
000D37r 1  E2 20 A9 01  	LoadSprite #$1, $c, playerSpriteX, $a, playerAttrs
000D3Br 1  85 00 C2 20  
000D3Fr 1  A5 rr 85 01  
000D56r 1               
000D56r 1               ; SetupScrollTable:
000D56r 1               	; clc
000D56r 1               	; lda scroll2X
000D56r 1               	; clc
000D56r 1               	; adc #$5
000D56r 1               	; sta scroll2X
000D56r 1               	; ror
000D56r 1               	; sta BG2ScrollTable
000D56r 1               	; ror
000D56r 1               	; sta BG2ScrollTable+2
000D56r 1               	; ror
000D56r 1               	; sta BG2ScrollTable+4
000D56r 1               	; ror
000D56r 1               	; sta BG2ScrollTable+6
000D56r 1               	; ror
000D56r 1               	; sta BG2ScrollTable+8
000D56r 1               	; a8
000D56r 1               
000D56r 1  A5 rr        	lda joypad
000D58r 1  85 rr        	sta joypadBuf
000D5Ar 1  A5 rr EB 85  	DrawWord scrollScreenNum, #$5, #$a
000D5Er 1  00 A9 05 00  
000D62r 1  85 02 A9 0A  
000D79r 1  A5 rr EB 85  	DrawWord playerX+2, #$5, #$9
000D7Dr 1  00 A9 05 00  
000D81r 1  85 02 A9 09  
000D98r 1  A5 rr EB 85  	DrawWord playerXSpeed, #$9, #$b
000D9Cr 1  00 A9 09 00  
000DA0r 1  85 02 A9 0B  
000DB7r 1  A5 rr EB 85  	DrawWord playerXSpeed+2, #$5, #$b
000DBBr 1  00 A9 05 00  
000DBFr 1  85 02 A9 0B  
000DD6r 1               	; DrawWord playerX, #$9, #$9
000DD6r 1  E2 20        	a8
000DD8r 1  64 rr        	stz frameStatus
000DDAr 1  CB           	wai
000DDBr 1  4C rr rr     	jmp MainLoop
000DDEr 1               
000DDEr 1               VBlank:
000DDEr 1  08           	php
000DDFr 1  8B           	phb
000DE0r 1  0B           	phd
000DE1r 1  48           	pha ;push regs to stack so if my main loop is ever too long it'll continue without
000DE2r 1  DA           	phx ;fucking up
000DE3r 1  5A           	phy
000DE4r 1  E2 20        	a8
000DE6r 1  A5 rr        	lda watchDog
000DE8r 1  1A           	inc a
000DE9r 1  C9 40        	cmp #$40
000DEBr 1  D0 01        	bne GameNotCrashed
000DEDr 1  00           		brk
000DEEr 1               	GameNotCrashed:
000DEEr 1  85 rr        	sta watchDog
000DF0r 1  A5 rr        	lda frameStatus
000DF2r 1  D0 3D        	bne SkipVblank
000DF4r 1  A9 80        	lda #FORCEBLANK
000DF6r 1  8D 00 21     	sta PPUBRIGHT
000DF9r 1  C2 20 A5 rr  	SetHScroll scrollX
000DFDr 1  E2 20 8D 0D  
000E01r 1  21 EB 8D 0D  
000E06r 1  C2 20 A5 rr  	SetVScroll scrollY
000E0Ar 1  E2 20 8D 0E  
000E0Er 1  21 EB 8D 0E  
000E13r 1  20 rr rr     	jsr TransferTextQueue
000E16r 1               
000E16r 1  C2 20        	a16
000E18r 1  A5 rr        	lda scrollMirrorPtr ;how I check if need to copy scroll data or not
000E1Ar 1  F0 03        	beq DontCopyScroll
000E1Cr 1  20 rr rr     		jsr VramScrollCopy
000E1Fr 1               	DontCopyScroll:
000E1Fr 1  E2 20        	a8
000E21r 1  20 rr rr     	jsr DMASpriteMirror
000E24r 1  A9 01        	lda #$1 ;start dma transfer on channel 1 (change to 3 if i reenable dmatilemapmirror)
000E26r 1  8D 0B 42     	sta $420b
000E29r 1               	; jsr SetupHDMA
000E29r 1               
000E29r 1  A9 0F        	lda #$F ;disable force blank, set back to max brightness
000E2Br 1  8D 00 21     	sta PPUBRIGHT
000E2Er 1  AD 10 42     	lda $4210 ;clear vblank flag
000E31r 1               SkipVblank:
000E31r 1  7A           	ply
000E32r 1  FA           	plx
000E33r 1  68           	pla
000E34r 1  2B           	pld
000E35r 1  AB           	plb
000E36r 1  28           	plp
000E37r 1               
000E37r 1  40           	rti
000E38r 1               
000E38r 1               SetupVideo:
000E38r 1  08               php
000E39r 1               
000E39r 1  A9 63        	lda #OBSIZE_16_32 | $3
000E3Br 1  8D 01 21     	sta OBSEL ;16x16 or 32x32 sprites, sprite data @ $6000
000E3Er 1  9C 02 21     	stz OAMADDR ;set OAM write cursor to $0
000E41r 1  9C 03 21     	stz OAMADDR+1
000E44r 1  A9 19        	lda #%00011001
000E46r 1  8D 05 21         sta BGMODE ;mode 1, 16x16 tiles in bg 1, 8x8 tiles in bgs 2 and 3
000E49r 1               
000E49r 1  A9 00            lda #$0 ;bg1 tilemap offset $0, size 32x32
000E4Br 1  8D 07 21         sta NTADDR
000E4Er 1               
000E4Er 1  A9 20        	lda #$20  ; bg2 tilemap offset: $2000, size: 32x32
000E50r 1  8D 08 21     	sta NTADDR+1
000E53r 1               
000E53r 1  A9 4C        	lda #$4c
000E55r 1  8D 09 21     	sta NTADDR+2 ;bg3 tilemap offset: $4C00, size 32x32
000E58r 1               
000E58r 1  A9 31        	lda #$31
000E5Ar 1  8D 0B 21         sta BGCHRADDR ;bg2 chr vram addr to $3000, bg1 chr vram offset $1000
000E5Dr 1               
000E5Dr 1  A9 04        	lda #$04
000E5Fr 1  8D 0C 21     	sta BGCHRADDR+1 ;bg3 chr vram addr is $4000
000E62r 1               
000E62r 1  A9 17            lda #%00010111 ;enable bg1, bg2, bg3, and sprites
000E64r 1  8D 2C 21         sta BLENDMAIN
000E67r 1               
000E67r 1  A9 0F            lda #$F ;max brightness
000E69r 1  8D 00 21         sta PPUBRIGHT
000E6Cr 1               
000E6Cr 1  28               plp
000E6Dr 1  60               rts
000E6Er 1               
000E6Er 1               
000E6Er 1               ; ScrollTable:
000E6Er 1               	; .byte $80
000E6Er 1               	; .word $0000
000E6Er 1               	; .byte $10
000E6Er 1               	; .word BG2ScrollTable+8
000E6Er 1               	; .byte $10
000E6Er 1               	; .word BG2ScrollTable+6
000E6Er 1               	; .byte $10
000E6Er 1               	; .word BG2ScrollTable+4
000E6Er 1               	; .byte $10
000E6Er 1               	; .word BG2ScrollTable+2
000E6Er 1               	; .byte $10
000E6Er 1               	; .word BG2ScrollTable
000E6Er 1               	; .byte $00
000E6Er 1               
000E6Er 1               ; PaletteIndexTable: ;needed because palette index auto-increments after every write
000E6Er 1               ; ;400 instead of $4 because the endianness of the CGRAM write port is reversed for some reason
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $400
000E6Er 1               	; .byte $00
000E6Er 1               
000E6Er 1               
000E6Er 1               ; GradientTable:
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $71C4; R:4 G:14 B:28
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $5DC7; R:7 G:14 B:23
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $51CB; R:11 G:14 B:20
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $49CD; R:13 G:14 B:18
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $41F1; R:17 G:15 B:16
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $35F4; R:20 G:15 B:13
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $2DF7; R:23 G:15 B:11
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $221A; R:26 G:16 B:8
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $1A1C; R:28 G:16 B:6
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $121F; R:31 G:16 B:4
000E6Er 1               	; .byte $C
000E6Er 1               	; .word $71A1
000E6Er 1               	; .byte $00
000E6Er 1               
000E6Er 1               DMASpriteMirror:
000E6Er 1  9C 02 21     	stz OAMADDR		; set OAM write cursor to 0
000E71r 1  9C 03 21     	stz OAMADDR+1
000E74r 1               
000E74r 1  A9 00        	lda #DMA_LINEAR
000E76r 1  8D 00 43     	sta DMAMODE
000E79r 1  A9 04        	lda #$04 ;write to $2104 (OAMDATA)
000E7Br 1  8D 01 43     	sta DMAPPUREG
000E7Er 1  A0 00 04     	ldy #OamMirror
000E81r 1  8C 02 43     	sty DMAADDR		; source offset
000E84r 1  A9 7E        	lda #$7E
000E86r 1  8D 04 43     	sta DMAADDRBANK		; bank address = $7E  (work RAM)
000E89r 1  A0 20 02     	ldy #$0220
000E8Cr 1  8C 05 43     	sty DMALEN		; number of bytes to transfer
000E8Fr 1  60           	rts
000E90r 1               
000E90r 1               
